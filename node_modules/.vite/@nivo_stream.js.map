{
  "version": 3,
  "sources": ["../@nivo/stream/node_modules/@react-spring/web/src/index.ts", "../@nivo/stream/node_modules/@react-spring/web/src/applyAnimatedValues.ts", "../@nivo/stream/node_modules/@react-spring/web/src/AnimatedStyle.ts", "../@nivo/stream/node_modules/@react-spring/web/src/primitives.ts", "../@nivo/stream/src/StreamLayer.tsx", "../@nivo/stream/src/StreamLayers.tsx", "../@nivo/stream/src/StreamDots.tsx", "../@nivo/stream/src/StreamSlicesItem.tsx", "../@nivo/stream/src/StreamSlices.tsx", "../@nivo/stream/src/props.ts", "../@nivo/stream/src/StreamDotsItem.tsx", "../@nivo/stream/src/LayerTooltip.tsx", "../@nivo/stream/src/StackTooltip.tsx", "../@nivo/stream/src/Stream.tsx", "../@nivo/stream/src/hooks.ts", "../@nivo/stream/src/ResponsiveStream.tsx"],
  "sourcesContent": ["import { Globals } from '@react-spring/core'\nimport { unstable_batchedUpdates } from 'react-dom'\nimport { createStringInterpolator, colors } from '@react-spring/shared'\nimport { createHost } from '@react-spring/animated'\nimport { applyAnimatedValues } from './applyAnimatedValues'\nimport { AnimatedStyle } from './AnimatedStyle'\nimport { WithAnimated } from './animated'\nimport { primitives } from './primitives'\n\nGlobals.assign({\n  batchedUpdates: unstable_batchedUpdates,\n  createStringInterpolator,\n  colors,\n})\n\nconst host = createHost(primitives, {\n  applyAnimatedValues,\n  createAnimatedStyle: style => new AnimatedStyle(style),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props,\n})\n\nexport const animated = host.animated as WithAnimated\nexport { animated as a }\n\nexport * from './animated'\nexport * from '@react-spring/core'\n", "import { Lookup } from '@react-spring/types'\n\nconst isCustomPropRE = /^--/\n\ntype Value = string | number | boolean | null\n\nfunction dangerousStyleValue(name: string, value: Value) {\n  if (value == null || typeof value === 'boolean' || value === '') return ''\n  if (\n    typeof value === 'number' &&\n    value !== 0 &&\n    !isCustomPropRE.test(name) &&\n    !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])\n  )\n    return value + 'px'\n  // Presumes implicit 'px' suffix for unitless numbers\n  return ('' + value).trim()\n}\n\nconst attributeCache: Lookup<string> = {}\n\ntype Instance = HTMLDivElement & { style?: Lookup }\n\nexport function applyAnimatedValues(instance: Instance, props: Lookup) {\n  if (!instance.nodeType || !instance.setAttribute) {\n    return false\n  }\n\n  const isFilterElement =\n    instance.nodeName === 'filter' ||\n    (instance.parentNode && instance.parentNode.nodeName === 'filter')\n\n  const {\n    className,\n    style,\n    children,\n    scrollTop,\n    scrollLeft,\n    viewBox,\n    ...attributes\n  } = props!\n\n  const values = Object.values(attributes)\n  const names = Object.keys(attributes).map(name =>\n    isFilterElement || instance.hasAttribute(name)\n      ? name\n      : attributeCache[name] ||\n        (attributeCache[name] = name.replace(\n          /([A-Z])/g,\n          // Attributes are written in dash case\n          n => '-' + n.toLowerCase()\n        ))\n  )\n\n  if (children !== void 0) {\n    instance.textContent = children\n  }\n\n  // Apply CSS styles\n  for (const name in style) {\n    if (style.hasOwnProperty(name)) {\n      const value = dangerousStyleValue(name, style[name])\n      if (isCustomPropRE.test(name)) {\n        instance.style.setProperty(name, value)\n      } else {\n        instance.style[name] = value\n      }\n    }\n  }\n\n  // Apply DOM attributes\n  names.forEach((name, i) => {\n    instance.setAttribute(name, values[i])\n  })\n\n  if (className !== void 0) {\n    instance.className = className\n  }\n  if (scrollTop !== void 0) {\n    instance.scrollTop = scrollTop\n  }\n  if (scrollLeft !== void 0) {\n    instance.scrollLeft = scrollLeft\n  }\n  if (viewBox !== void 0) {\n    instance.setAttribute('viewBox', viewBox)\n  }\n}\n\nlet isUnitlessNumber: { [key: string]: true } = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true,\n}\n\nconst prefixKey = (prefix: string, key: string) =>\n  prefix + key.charAt(0).toUpperCase() + key.substring(1)\nconst prefixes = ['Webkit', 'Ms', 'Moz', 'O']\n\nisUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {\n  prefixes.forEach(prefix => (acc[prefixKey(prefix, prop)] = acc[prop]))\n  return acc\n}, isUnitlessNumber)\n", "import { AnimatedObject } from '@react-spring/animated'\nimport { Lookup, OneOrMore } from '@react-spring/types'\nimport {\n  is,\n  each,\n  toArray,\n  eachProp,\n  FluidValue,\n  FluidEvent,\n  getFluidValue,\n  callFluidObservers,\n  hasFluidValue,\n  addFluidObserver,\n  removeFluidObserver,\n} from '@react-spring/shared'\n\n/** The transform-functions\n * (https://developer.mozilla.org/fr/docs/Web/CSS/transform-function)\n * that you can pass as keys to your animated component style and that will be\n * animated. Perspective has been left out as it would conflict with the\n * non-transform perspective style.\n */\nconst domTransforms = /^(matrix|translate|scale|rotate|skew)/\n\n// These keys have \"px\" units by default\nconst pxTransforms = /^(translate)/\n\n// These keys have \"deg\" units by default\nconst degTransforms = /^(rotate|skew)/\n\ntype Value = number | string\n\n/** Add a unit to the value when the value is unit-less (eg: a number) */\nconst addUnit = (value: Value, unit: string): string | 0 =>\n  is.num(value) && value !== 0 ? value + unit : value\n\n/**\n * Checks if the input value matches the identity value.\n *\n *     isValueIdentity(0, 0)              // => true\n *     isValueIdentity('0px', 0)          // => true\n *     isValueIdentity([0, '0px', 0], 0)  // => true\n */\nconst isValueIdentity = (value: OneOrMore<Value>, id: number): boolean =>\n  is.arr(value)\n    ? value.every(v => isValueIdentity(v, id))\n    : is.num(value)\n      ? value === id\n      : parseFloat(value) === id\n\ntype Inputs = ReadonlyArray<Value | FluidValue<Value>>[]\ntype Transforms = ((value: any) => [string, boolean])[]\n\n/**\n * This AnimatedStyle will simplify animated components transforms by\n * interpolating all transform function passed as keys in the style object\n * including shortcuts such as x, y and z for translateX/Y/Z\n */\nexport class AnimatedStyle extends AnimatedObject {\n  constructor({ x, y, z, ...style }: Lookup) {\n    /**\n     * An array of arrays that contains the values (static or fluid)\n     * used by each transform function.\n     */\n    const inputs: Inputs = []\n    /**\n     * An array of functions that take a list of values (static or fluid)\n     * and returns (1) a CSS transform string and (2) a boolean that's true\n     * when the transform has no effect (eg: an identity transform).\n     */\n    const transforms: Transforms = []\n\n    // Combine x/y/z into translate3d\n    if (x || y || z) {\n      inputs.push([x || 0, y || 0, z || 0])\n      transforms.push((xyz: Value[]) => [\n        `translate3d(${xyz.map(v => addUnit(v, 'px')).join(',')})`, // prettier-ignore\n        isValueIdentity(xyz, 0),\n      ])\n    }\n\n    // Pluck any other transform-related props\n    eachProp(style, (value, key) => {\n      if (key === 'transform') {\n        inputs.push([value || ''])\n        transforms.push((transform: string) => [transform, transform === ''])\n      } else if (domTransforms.test(key)) {\n        delete style[key]\n        if (is.und(value)) return\n\n        const unit = pxTransforms.test(key)\n          ? 'px'\n          : degTransforms.test(key)\n            ? 'deg'\n            : ''\n\n        inputs.push(toArray(value))\n        transforms.push(\n          key === 'rotate3d'\n            ? ([x, y, z, deg]: [number, number, number, Value]) => [\n                `rotate3d(${x},${y},${z},${addUnit(deg, unit)})`,\n                isValueIdentity(deg, 0),\n              ]\n            : (input: Value[]) => [\n                `${key}(${input.map(v => addUnit(v, unit)).join(',')})`,\n                isValueIdentity(input, key.startsWith('scale') ? 1 : 0),\n              ]\n        )\n      }\n    })\n\n    if (inputs.length) {\n      style.transform = new FluidTransform(inputs, transforms)\n    }\n\n    super(style)\n  }\n}\n\n/** @internal */\nclass FluidTransform extends FluidValue<string> {\n  protected _value: string | null = null\n\n  constructor(\n    readonly inputs: Inputs,\n    readonly transforms: Transforms\n  ) {\n    super()\n  }\n\n  get() {\n    return this._value || (this._value = this._get())\n  }\n\n  protected _get() {\n    let transform = ''\n    let identity = true\n    each(this.inputs, (input, i) => {\n      const arg1 = getFluidValue(input[0])\n      const [t, id] = this.transforms[i](\n        is.arr(arg1) ? arg1 : input.map(getFluidValue)\n      )\n      transform += ' ' + t\n      identity = identity && id\n    })\n    return identity ? 'none' : transform\n  }\n\n  // Start observing our inputs once we have an observer.\n  protected observerAdded(count: number) {\n    if (count == 1)\n      each(this.inputs, input =>\n        each(\n          input,\n          value => hasFluidValue(value) && addFluidObserver(value, this)\n        )\n      )\n  }\n\n  // Stop observing our inputs once we have no observers.\n  protected observerRemoved(count: number) {\n    if (count == 0)\n      each(this.inputs, input =>\n        each(\n          input,\n          value => hasFluidValue(value) && removeFluidObserver(value, this)\n        )\n      )\n  }\n\n  eventObserved(event: FluidEvent) {\n    if (event.type == 'change') {\n      this._value = null\n    }\n    callFluidObservers(this, event)\n  }\n}\n", "export type Primitives = keyof JSX.IntrinsicElements\nexport const primitives: Primitives[] = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  // SVG\n  'circle',\n  'clipPath',\n  'defs',\n  'ellipse',\n  'foreignObject',\n  'g',\n  'image',\n  'line',\n  'linearGradient',\n  'mask',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialGradient',\n  'rect',\n  'stop',\n  'svg',\n  'text',\n  'tspan',\n]\n", "import { useCallback, createElement, MouseEvent } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamLayerData } from './types'\n\ninterface StreamLayerProps<RawDatum extends StreamDatum> {\n    layer: StreamLayerData\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayer = <RawDatum extends StreamDatum>({\n    layer,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayerProps<RawDatum>) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGPathElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { layer }), event, 'left')\n        },\n        [showTooltipFromEvent, layer]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(layer.path)\n    const animatedProps = useSpring({\n        color: layer.color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={layer.fill ? layer.fill : animatedProps.color}\n            fillOpacity={fillOpacity}\n            stroke={getBorderColor(layer)}\n            strokeWidth={borderWidth}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? hideTooltip : undefined}\n        />\n    )\n}\n", "import { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { StreamLayer } from './StreamLayer'\nimport { StreamCommonProps, StreamLayerData, StreamDatum } from './types'\n\ninterface StreamLayersProps<RawDatum extends StreamDatum> {\n    layers: StreamLayerData[]\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayers = <RawDatum extends StreamDatum>({\n    layers,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayersProps<RawDatum>) => (\n    <g>\n        {layers.map((layer, i) => (\n            <StreamLayer<RawDatum>\n                key={i}\n                layer={layer}\n                getBorderColor={getBorderColor}\n                borderWidth={borderWidth}\n                fillOpacity={fillOpacity}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n", "import { createElement } from 'react'\nimport { StreamSvgProps, StreamLayerDatum, StreamDatum } from './types'\n\ninterface StreamDotsProps<RawDatum extends StreamDatum> {\n    id: string | number\n    color: string\n    data: StreamLayerDatum[]\n    dotComponent: Exclude<StreamSvgProps<RawDatum>['dotComponent'], undefined>\n    position: 'start' | 'center' | 'end'\n    getSize: (datum: StreamLayerDatum) => number\n    getColor: (datum: StreamLayerDatum) => string\n    getBorderWidth: (datum: StreamLayerDatum) => number\n    getBorderColor: (datum: StreamLayerDatum) => string\n}\n\nconst getDotY = <RawDatum extends StreamDatum>(\n    datum: StreamLayerDatum,\n    position: StreamDotsProps<RawDatum>['position']\n) => {\n    let y = datum.y2\n    if (position === 'center') {\n        y = datum.y1 + (datum.y2 - datum.y1) / 2\n    } else if (position === 'start') {\n        y = datum.y1\n    }\n\n    return y\n}\n\nexport const StreamDots = <RawDatum extends StreamDatum>({\n    data,\n    dotComponent,\n    position,\n    getSize,\n    getColor,\n    getBorderWidth,\n    getBorderColor,\n}: StreamDotsProps<RawDatum>) => (\n    <>\n        {data.map((datum, i) => {\n            return createElement(dotComponent, {\n                key: i,\n                datum,\n                x: datum.x,\n                y: getDotY<RawDatum>(datum, position),\n                size: getSize(datum),\n                color: getColor(datum),\n                borderWidth: getBorderWidth(datum),\n                borderColor: getBorderColor(datum),\n            })\n        })}\n    </>\n)\n", "import { createElement, useCallback, useState, MouseEvent } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamSliceData } from './types'\n\ninterface StreamSlicesItemProps<RawDatum extends StreamDatum> {\n    slice: StreamSliceData\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlicesItem = <RawDatum extends StreamDatum>({\n    slice,\n    height,\n    tooltip,\n}: StreamSlicesItemProps<RawDatum>) => {\n    const [isHover, setIsHover] = useState(false)\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            setIsHover(true)\n            showTooltipFromEvent(createElement(tooltip, { slice }), event, 'left')\n        },\n        [setIsHover, showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        setIsHover(false)\n        hideTooltip()\n    }, [setIsHover, hideTooltip])\n\n    return (\n        <g transform={`translate(${slice.x}, 0)`}>\n            {isHover && (\n                <line\n                    x1={0}\n                    x2={0}\n                    y1={0}\n                    y2={height}\n                    stroke=\"#000\"\n                    strokeOpacity={0.35}\n                    strokeWidth={1}\n                />\n            )}\n            <rect\n                x={-20}\n                width={40}\n                height={height}\n                fill=\"#000\"\n                fillOpacity={0}\n                onMouseEnter={handleMouseHover}\n                onMouseMove={handleMouseHover}\n                onMouseLeave={handleMouseLeave}\n            />\n        </g>\n    )\n}\n", "import { StreamSliceData, StreamDatum, StreamCommonProps } from './types'\nimport { StreamSlicesItem } from './StreamSlicesItem'\n\ninterface StreamSlicesProps<RawDatum extends StreamDatum> {\n    slices: StreamSliceData[]\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlices = <RawDatum extends StreamDatum>({\n    slices,\n    height,\n    tooltip,\n}: StreamSlicesProps<RawDatum>) => (\n    <g>\n        {slices.map(slice => (\n            <StreamSlicesItem<RawDatum>\n                key={slice.index}\n                slice={slice}\n                height={height}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n", "import { StackOrder, StackOffset, AreaCurve } from '@nivo/core'\nimport { StreamCommonProps, StreamLayerId } from './types'\nimport { StreamDotsItem } from './StreamDotsItem'\nimport { LayerTooltip } from './LayerTooltip'\nimport { StackTooltip } from './StackTooltip'\n\nexport const defaultProps = {\n    label: 'id',\n\n    order: 'none' as StackOrder,\n    offsetType: 'wiggle' as StackOffset,\n    curve: 'catmullRom' as AreaCurve,\n\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: false,\n    enableGridY: true,\n\n    colors: { scheme: 'nivo' } as StreamCommonProps<any>['colors'],\n    fillOpacity: 1,\n    borderWidth: 0,\n    borderColor: {\n        from: 'color',\n        modifiers: [['darker', 1]],\n    } as StreamCommonProps<any>['borderColor'],\n\n    enableDots: false,\n    dotPosition: 'center' as StreamCommonProps<any>['dotPosition'],\n    dotComponent: StreamDotsItem,\n    dotSize: 6,\n    dotColor: { from: 'color' },\n    dotBorderWidth: 0,\n    dotBorderColor: { from: 'color' },\n\n    isInteractive: true,\n    tooltip: LayerTooltip,\n    enableStackTooltip: true,\n    stackTooltip: StackTooltip,\n\n    legends: [],\n    legendLabel: 'id',\n\n    role: 'application',\n}\n\nexport const svgDefaultProps = {\n    ...defaultProps,\n    layers: ['grid', 'axes', 'layers', 'dots', 'slices', 'legends'] as StreamLayerId[],\n\n    defs: [],\n    fill: [],\n\n    animate: true,\n    motionConfig: 'default',\n\n    role: 'img',\n    isFocusable: false,\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\n\nexport interface StreamDotsItemProps {\n    x: number\n    y: number\n    size: number\n    color: string\n    borderWidth: number\n    borderColor: string\n}\n\nexport const StreamDotsItem = ({\n    x,\n    y,\n    size,\n    color,\n    borderWidth,\n    borderColor,\n}: StreamDotsItemProps) => {\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size * 0.5,\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.circle\n            cx={animatedProps.x}\n            cy={animatedProps.y}\n            r={animatedProps.radius}\n            fill={animatedProps.color}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n        />\n    )\n}\n", "import { BasicTooltip } from '@nivo/tooltip'\nimport { TooltipProps } from './types'\n\nexport const LayerTooltip = ({ layer }: TooltipProps) => (\n    <BasicTooltip id={layer.label} enableChip={true} color={layer.color} />\n)\n", "import { useMemo } from 'react'\nimport { TableTooltip, Chip } from '@nivo/tooltip'\nimport { StackTooltipProps } from './types'\n\nexport const StackTooltip = ({ slice }: StackTooltipProps) => {\n    const rows = useMemo(\n        () =>\n            slice.stack.map(p => [\n                <Chip key={p.layerId} color={p.color} />,\n                p.layerLabel,\n                p.formattedValue,\n            ]),\n        [slice]\n    )\n\n    return <TableTooltip rows={rows} />\n}\n", "import { createElement, Fragment, ReactNode } from 'react'\nimport {\n    Container,\n    SvgWrapper,\n    useDimensions,\n    // @ts-ignore\n    bindDefs,\n} from '@nivo/core'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { StreamLayers } from './StreamLayers'\nimport { StreamDots } from './StreamDots'\nimport { StreamSlices } from './StreamSlices'\nimport { useStream } from './hooks'\nimport { svgDefaultProps } from './props'\nimport { StreamDatum, StreamLayerId, StreamSvgProps } from './types'\n\ntype InnerStreamProps<RawDatum extends StreamDatum> = Omit<\n    StreamSvgProps<RawDatum>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerStream = <RawDatum extends StreamDatum>({\n    data,\n    keys,\n    label,\n    valueFormat,\n\n    offsetType,\n    order,\n    curve,\n\n    layers: chartLayers = svgDefaultProps.layers,\n\n    width,\n    height,\n    margin: partialMargin,\n\n    axisTop,\n    axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n\n    colors,\n    fillOpacity = svgDefaultProps.fillOpacity,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n\n    enableDots = svgDefaultProps.enableDots,\n    dotPosition = svgDefaultProps.dotPosition,\n    dotComponent = svgDefaultProps.dotComponent,\n    dotSize,\n    dotColor,\n    dotBorderWidth,\n    dotBorderColor,\n\n    isInteractive = svgDefaultProps.isInteractive,\n    tooltip = svgDefaultProps.tooltip,\n    enableStackTooltip = svgDefaultProps.enableStackTooltip,\n    stackTooltip = svgDefaultProps.stackTooltip,\n\n    legends = svgDefaultProps.legends,\n\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n}: InnerStreamProps<RawDatum>) => {\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        xScale,\n        yScale,\n        layers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    } = useStream<RawDatum>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        keys,\n        label,\n        valueFormat,\n        offsetType,\n        order,\n        curve,\n        colors,\n        borderColor,\n        dotSize,\n        dotColor,\n        dotBorderWidth,\n        dotBorderColor,\n    })\n\n    const boundDefs = bindDefs(defs, layers, fill)\n\n    const layerById: Record<StreamLayerId, ReactNode> = {\n        grid: null,\n        axes: null,\n        layers: null,\n        dots: null,\n        slices: null,\n        legends: null,\n    }\n\n    if (chartLayers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n            />\n        )\n    }\n\n    if (chartLayers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (chartLayers.includes('layers')) {\n        layerById.layers = (\n            <StreamLayers<RawDatum>\n                key=\"layers\"\n                layers={layers}\n                fillOpacity={fillOpacity}\n                borderWidth={borderWidth}\n                getBorderColor={getBorderColor}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('dots') && enableDots) {\n        layerById.dots = (\n            <Fragment key=\"dots\">\n                {layers.map(layer => (\n                    <StreamDots\n                        key={layer.id}\n                        id={layer.id}\n                        color={layer.color}\n                        data={layer.data}\n                        dotComponent={dotComponent}\n                        position={dotPosition}\n                        getSize={getDotSize}\n                        getColor={getDotColor}\n                        getBorderWidth={getDotBorderWidth}\n                        getBorderColor={getDotBorderColor}\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    if (chartLayers.includes('slices') && isInteractive && enableStackTooltip) {\n        layerById.slices = (\n            <StreamSlices<RawDatum>\n                key=\"slices\"\n                slices={slices}\n                height={innerHeight}\n                tooltip={stackTooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('legends')) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => {\n                    const legendData = layers\n                        .map(layer => ({\n                            id: layer.id,\n                            label: layer.label,\n                            color: layer.color,\n                            fill: layer.fill,\n                        }))\n                        .reverse()\n\n                    return (\n                        <BoxLegendSvg\n                            key={i}\n                            {...legend}\n                            containerWidth={innerWidth}\n                            containerHeight={innerHeight}\n                            data={legendData}\n                        />\n                    )\n                })}\n            </Fragment>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {chartLayers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Stream = <RawDatum extends StreamDatum>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: StreamSvgProps<RawDatum>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerStream<RawDatum> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n", "import { useMemo } from 'react'\nimport { area, stack as d3Stack } from 'd3-shape'\nimport {\n    useTheme,\n    usePropertyAccessor,\n    useValueFormatter,\n    useCurveInterpolation,\n    // @ts-ignore\n    stackOrderFromProp,\n    // @ts-ignore\n    stackOffsetFromProp,\n} from '@nivo/core'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport {\n    StreamCommonProps,\n    StreamCustomLayerProps,\n    StreamDataProps,\n    StreamDatum,\n    StreamLayerData,\n    StreamLayerDatum,\n    StreamSliceData,\n} from './types'\nimport { defaultProps } from './props'\nimport { createLinearScale, createPointScale } from '@nivo/scales'\n\nexport const useStream = <RawDatum extends StreamDatum>({\n    width,\n    height,\n    data,\n    keys,\n    label = defaultProps.label,\n    valueFormat,\n    offsetType = defaultProps.offsetType,\n    order = defaultProps.order,\n    curve = defaultProps.curve,\n    colors = defaultProps.colors,\n    borderColor = defaultProps.borderColor,\n    dotSize = defaultProps.dotSize,\n    dotColor = defaultProps.dotColor,\n    dotBorderWidth = defaultProps.dotBorderWidth,\n    dotBorderColor = defaultProps.dotBorderColor,\n}: {\n    width: number\n    height: number\n    data: StreamDataProps<RawDatum>['data']\n    keys: StreamDataProps<RawDatum>['keys']\n    label?: StreamCommonProps<RawDatum>['label']\n    valueFormat?: StreamCommonProps<RawDatum>['valueFormat']\n    offsetType?: StreamCommonProps<RawDatum>['offsetType']\n    order?: StreamCommonProps<RawDatum>['order']\n    curve?: StreamCommonProps<RawDatum>['curve']\n    colors?: StreamCommonProps<RawDatum>['colors']\n    dotSize?: StreamCommonProps<RawDatum>['dotSize']\n    dotColor?: StreamCommonProps<RawDatum>['dotColor']\n    dotBorderWidth?: StreamCommonProps<RawDatum>['dotBorderWidth']\n    dotBorderColor?: StreamCommonProps<RawDatum>['dotBorderColor']\n    borderColor?: StreamCommonProps<RawDatum>['borderColor']\n}) => {\n    const areaCurveFactory = useCurveInterpolation(curve)\n    const areaGenerator = useMemo(\n        () =>\n            area<StreamLayerDatum>()\n                .x(({ x }) => x)\n                .y0(({ y1 }) => y1)\n                .y1(({ y2 }) => y2)\n                .curve(areaCurveFactory),\n        [areaCurveFactory]\n    )\n\n    const stack = useMemo(\n        () =>\n            d3Stack<RawDatum, string | number>()\n                .keys(keys)\n                .offset(stackOffsetFromProp(offsetType))\n                .order(stackOrderFromProp(order)),\n        [keys, offsetType, order]\n    )\n\n    const [layers, xScale, yScale] = useMemo(() => {\n        const allMin: number[] = []\n        const allMax: number[] = []\n\n        const layers = stack(data).map(layer => {\n            return layer.map(point => {\n                allMin.push(point[0])\n                allMax.push(point[1])\n\n                return {\n                    ...point,\n                    value: point.data[layer.key] as number,\n                }\n            })\n        })\n\n        const minValue = Math.min(...allMin)\n        const maxValue = Math.max(...allMax)\n\n        const xScale = createPointScale(\n            { type: 'point' },\n            { all: Array.from({ length: data.length }, (_, i) => i), min: 0, max: data.length },\n            width\n        )\n        const yScale = createLinearScale(\n            { type: 'linear', min: minValue },\n            { all: [minValue, maxValue], min: minValue, max: maxValue },\n            height,\n            'y'\n        )\n        return [layers, xScale, yScale]\n    }, [stack, data, width, height])\n\n    const theme = useTheme()\n    const getColor = useOrdinalColorScale<Omit<StreamLayerData, 'label' | 'color' | 'data'>>(\n        colors,\n        'id'\n    )\n    const getBorderColor = useInheritedColor<StreamLayerData>(borderColor, theme)\n\n    const getDotSize = useMemo(\n        () => (typeof dotSize === 'function' ? dotSize : () => dotSize),\n        [dotSize]\n    )\n    const getDotColor = useInheritedColor(dotColor, theme)\n    const getDotBorderWidth = useMemo(\n        () => (typeof dotBorderWidth === 'function' ? dotBorderWidth : () => dotBorderWidth),\n        [dotBorderWidth]\n    )\n    const getDotBorderColor = useInheritedColor(dotBorderColor, theme)\n\n    const getLabel = usePropertyAccessor<\n        Omit<StreamLayerData, 'label' | 'color' | 'data'>,\n        string | number\n    >(label)\n    const formatValue = useValueFormatter(valueFormat)\n\n    const enhancedLayers: StreamLayerData[] = useMemo(\n        () =>\n            layers.map((points, layerIndex) => {\n                const computedPoints: StreamLayerDatum[] = points.map((point, i) => ({\n                    layerId: keys[layerIndex],\n                    layerLabel: '',\n                    index: i,\n                    color: '',\n                    x: xScale(i) as number,\n                    value: point.value,\n                    formattedValue: formatValue(point.value),\n                    y1: yScale(point[0]),\n                    y2: yScale(point[1]),\n                }))\n\n                const layer: Omit<StreamLayerData, 'label' | 'color' | 'data'> = {\n                    id: keys[layerIndex] as string,\n                    path: areaGenerator(computedPoints) as string,\n                }\n\n                const layerWithComputedProperties: Omit<StreamLayerData, 'data'> = {\n                    ...layer,\n                    label: getLabel(layer),\n                    color: getColor(layer),\n                }\n\n                return {\n                    ...layerWithComputedProperties,\n                    data: computedPoints.map(point => {\n                        point.layerLabel = layerWithComputedProperties.label\n                        point.color = layerWithComputedProperties.color\n\n                        return point\n                    }),\n                }\n            }),\n        [layers, keys, getLabel, areaGenerator, getColor, xScale, yScale, formatValue]\n    )\n\n    const slices: StreamSliceData[] = useMemo(\n        () =>\n            Array.from({ length: data.length }, (_, i) => {\n                const sliceStack = enhancedLayers\n                    .map(layer => layer.data[i])\n                    .sort((a, b) => a.y2 - b.y2)\n\n                return {\n                    index: i,\n                    x: enhancedLayers[0].data[i].x,\n                    stack: sliceStack,\n                }\n            }),\n        [data.length, enhancedLayers]\n    )\n\n    const layerContext: StreamCustomLayerProps = useMemo(\n        () => ({\n            xScale,\n            yScale,\n            layers: enhancedLayers,\n            slices,\n        }),\n        [xScale, yScale, enhancedLayers, slices]\n    )\n\n    return {\n        xScale,\n        yScale,\n        layers: enhancedLayers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    }\n}\n", "import { ResponsiveWrapper } from '@nivo/core'\nimport { StreamDatum, StreamSvgProps } from './types'\nimport { Stream } from './Stream'\n\nexport const ResponsiveStream = <RawDatum extends StreamDatum>(\n    props: Omit<StreamSvgProps<RawDatum>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Stream<RawDatum> width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n"],
  "mappings": "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A2B;EACtC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AH9HF,gBAAQ,OAAO;EACb,gBAAgB;EAChB;EACA;;AAGF,IAAM,OAAO,WAAW,YAAY;EAClC;EACA,qBAAqB,CAAA,UAAS,IAAI,cAAc;EAEhD,mBAAmB,CAAC,OAAkC;AAAlC,iBAAE,aAAW,eAAb,IAA4B,kBAA5B,IAA4B,CAA1B,aAAW;AAA2B;;;AAGvD,IAAM,WAAW,KAAK;;;;;;;;;;;;;;AINtB,IAAM,IAAc,SAAH,IAAA;AAOU,MAN9B,KAAK,GAAL,OACA,KAAW,GAAX,aACA,IAAW,GAAX,aACA,IAAc,GAAd,gBACA,IAAa,GAAb,eACA,IAAO,GAAP,SAEA,IAA8C,KAAtC,IAAoB,EAApB,sBAAsB,IAAW,EAAX,aACxB,IAAmB,8BACrB,SAAC,IAAA;AACG,MAAqB,gCAAc,GAAS,EAAE,OAAA,OAAU,IAAO;KAEnE,CAAC,GAAsB,MAG3B,IAA0C,MAAlC,IAAO,EAAP,SAAiB,IAAY,EAApB,QACX,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",
  "names": []
}
