{
  "version": 3,
  "sources": ["../lodash/_baseIsDate.js", "../lodash/isDate.js", "../@nivo/scales/src/timeHelpers.ts", "../@nivo/scales/src/linearScale.ts", "../@nivo/scales/src/pointScale.ts", "../@nivo/scales/src/bandScale.ts", "../@nivo/scales/src/timeScale.ts", "../@nivo/scales/src/logScale.ts", "../@nivo/scales/src/symlogScale.ts", "../@nivo/scales/src/compute.ts", "../@nivo/scales/src/ticks.ts", "../@nivo/axes/node_modules/@react-spring/web/src/index.ts", "../@nivo/axes/node_modules/@react-spring/web/src/applyAnimatedValues.ts", "../@nivo/axes/node_modules/@react-spring/web/src/AnimatedStyle.ts", "../@nivo/axes/node_modules/@react-spring/web/src/primitives.ts", "../@nivo/axes/src/compute.ts", "../@nivo/axes/src/components/AxisTick.tsx", "../@nivo/axes/src/components/Axis.tsx", "../@nivo/axes/src/props.ts", "../@nivo/axes/src/components/Axes.tsx", "../@nivo/axes/src/components/GridLine.tsx", "../@nivo/axes/src/components/GridLines.tsx", "../@nivo/axes/src/components/Grid.tsx", "../@nivo/axes/src/canvas.ts"],
  "sourcesContent": ["var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar dateTag = '[object Date]';\n\n/**\n * The base implementation of `_.isDate` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n */\nfunction baseIsDate(value) {\n  return isObjectLike(value) && baseGetTag(value) == dateTag;\n}\n\nmodule.exports = baseIsDate;\n", "var baseIsDate = require('./_baseIsDate'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsDate = nodeUtil && nodeUtil.isDate;\n\n/**\n * Checks if `value` is classified as a `Date` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n * @example\n *\n * _.isDate(new Date);\n * // => true\n *\n * _.isDate('Mon April 23 2012');\n * // => false\n */\nvar isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\nmodule.exports = isDate;\n", "import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n", "import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n", "import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n", "import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n", "import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n", "import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n", "import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n", "import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n", "import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n", "import { Globals } from '@react-spring/core'\nimport { unstable_batchedUpdates } from 'react-dom'\nimport { createStringInterpolator, colors } from '@react-spring/shared'\nimport { createHost } from '@react-spring/animated'\nimport { applyAnimatedValues } from './applyAnimatedValues'\nimport { AnimatedStyle } from './AnimatedStyle'\nimport { WithAnimated } from './animated'\nimport { primitives } from './primitives'\n\nGlobals.assign({\n  batchedUpdates: unstable_batchedUpdates,\n  createStringInterpolator,\n  colors,\n})\n\nconst host = createHost(primitives, {\n  applyAnimatedValues,\n  createAnimatedStyle: style => new AnimatedStyle(style),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props,\n})\n\nexport const animated = host.animated as WithAnimated\nexport { animated as a }\n\nexport * from './animated'\nexport * from '@react-spring/core'\n", "import { Lookup } from '@react-spring/types'\n\nconst isCustomPropRE = /^--/\n\ntype Value = string | number | boolean | null\n\nfunction dangerousStyleValue(name: string, value: Value) {\n  if (value == null || typeof value === 'boolean' || value === '') return ''\n  if (\n    typeof value === 'number' &&\n    value !== 0 &&\n    !isCustomPropRE.test(name) &&\n    !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])\n  )\n    return value + 'px'\n  // Presumes implicit 'px' suffix for unitless numbers\n  return ('' + value).trim()\n}\n\nconst attributeCache: Lookup<string> = {}\n\ntype Instance = HTMLDivElement & { style?: Lookup }\n\nexport function applyAnimatedValues(instance: Instance, props: Lookup) {\n  if (!instance.nodeType || !instance.setAttribute) {\n    return false\n  }\n\n  const isFilterElement =\n    instance.nodeName === 'filter' ||\n    (instance.parentNode && instance.parentNode.nodeName === 'filter')\n\n  const {\n    className,\n    style,\n    children,\n    scrollTop,\n    scrollLeft,\n    viewBox,\n    ...attributes\n  } = props!\n\n  const values = Object.values(attributes)\n  const names = Object.keys(attributes).map(name =>\n    isFilterElement || instance.hasAttribute(name)\n      ? name\n      : attributeCache[name] ||\n        (attributeCache[name] = name.replace(\n          /([A-Z])/g,\n          // Attributes are written in dash case\n          n => '-' + n.toLowerCase()\n        ))\n  )\n\n  if (children !== void 0) {\n    instance.textContent = children\n  }\n\n  // Apply CSS styles\n  for (const name in style) {\n    if (style.hasOwnProperty(name)) {\n      const value = dangerousStyleValue(name, style[name])\n      if (isCustomPropRE.test(name)) {\n        instance.style.setProperty(name, value)\n      } else {\n        instance.style[name] = value\n      }\n    }\n  }\n\n  // Apply DOM attributes\n  names.forEach((name, i) => {\n    instance.setAttribute(name, values[i])\n  })\n\n  if (className !== void 0) {\n    instance.className = className\n  }\n  if (scrollTop !== void 0) {\n    instance.scrollTop = scrollTop\n  }\n  if (scrollLeft !== void 0) {\n    instance.scrollLeft = scrollLeft\n  }\n  if (viewBox !== void 0) {\n    instance.setAttribute('viewBox', viewBox)\n  }\n}\n\nlet isUnitlessNumber: { [key: string]: true } = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true,\n}\n\nconst prefixKey = (prefix: string, key: string) =>\n  prefix + key.charAt(0).toUpperCase() + key.substring(1)\nconst prefixes = ['Webkit', 'Ms', 'Moz', 'O']\n\nisUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {\n  prefixes.forEach(prefix => (acc[prefixKey(prefix, prop)] = acc[prop]))\n  return acc\n}, isUnitlessNumber)\n", "import { AnimatedObject } from '@react-spring/animated'\nimport { Lookup, OneOrMore } from '@react-spring/types'\nimport {\n  is,\n  each,\n  toArray,\n  eachProp,\n  FluidValue,\n  FluidEvent,\n  getFluidValue,\n  callFluidObservers,\n  hasFluidValue,\n  addFluidObserver,\n  removeFluidObserver,\n} from '@react-spring/shared'\n\n/** The transform-functions\n * (https://developer.mozilla.org/fr/docs/Web/CSS/transform-function)\n * that you can pass as keys to your animated component style and that will be\n * animated. Perspective has been left out as it would conflict with the\n * non-transform perspective style.\n */\nconst domTransforms = /^(matrix|translate|scale|rotate|skew)/\n\n// These keys have \"px\" units by default\nconst pxTransforms = /^(translate)/\n\n// These keys have \"deg\" units by default\nconst degTransforms = /^(rotate|skew)/\n\ntype Value = number | string\n\n/** Add a unit to the value when the value is unit-less (eg: a number) */\nconst addUnit = (value: Value, unit: string): string | 0 =>\n  is.num(value) && value !== 0 ? value + unit : value\n\n/**\n * Checks if the input value matches the identity value.\n *\n *     isValueIdentity(0, 0)              // => true\n *     isValueIdentity('0px', 0)          // => true\n *     isValueIdentity([0, '0px', 0], 0)  // => true\n */\nconst isValueIdentity = (value: OneOrMore<Value>, id: number): boolean =>\n  is.arr(value)\n    ? value.every(v => isValueIdentity(v, id))\n    : is.num(value)\n      ? value === id\n      : parseFloat(value) === id\n\ntype Inputs = ReadonlyArray<Value | FluidValue<Value>>[]\ntype Transforms = ((value: any) => [string, boolean])[]\n\n/**\n * This AnimatedStyle will simplify animated components transforms by\n * interpolating all transform function passed as keys in the style object\n * including shortcuts such as x, y and z for translateX/Y/Z\n */\nexport class AnimatedStyle extends AnimatedObject {\n  constructor({ x, y, z, ...style }: Lookup) {\n    /**\n     * An array of arrays that contains the values (static or fluid)\n     * used by each transform function.\n     */\n    const inputs: Inputs = []\n    /**\n     * An array of functions that take a list of values (static or fluid)\n     * and returns (1) a CSS transform string and (2) a boolean that's true\n     * when the transform has no effect (eg: an identity transform).\n     */\n    const transforms: Transforms = []\n\n    // Combine x/y/z into translate3d\n    if (x || y || z) {\n      inputs.push([x || 0, y || 0, z || 0])\n      transforms.push((xyz: Value[]) => [\n        `translate3d(${xyz.map(v => addUnit(v, 'px')).join(',')})`, // prettier-ignore\n        isValueIdentity(xyz, 0),\n      ])\n    }\n\n    // Pluck any other transform-related props\n    eachProp(style, (value, key) => {\n      if (key === 'transform') {\n        inputs.push([value || ''])\n        transforms.push((transform: string) => [transform, transform === ''])\n      } else if (domTransforms.test(key)) {\n        delete style[key]\n        if (is.und(value)) return\n\n        const unit = pxTransforms.test(key)\n          ? 'px'\n          : degTransforms.test(key)\n            ? 'deg'\n            : ''\n\n        inputs.push(toArray(value))\n        transforms.push(\n          key === 'rotate3d'\n            ? ([x, y, z, deg]: [number, number, number, Value]) => [\n                `rotate3d(${x},${y},${z},${addUnit(deg, unit)})`,\n                isValueIdentity(deg, 0),\n              ]\n            : (input: Value[]) => [\n                `${key}(${input.map(v => addUnit(v, unit)).join(',')})`,\n                isValueIdentity(input, key.startsWith('scale') ? 1 : 0),\n              ]\n        )\n      }\n    })\n\n    if (inputs.length) {\n      style.transform = new FluidTransform(inputs, transforms)\n    }\n\n    super(style)\n  }\n}\n\n/** @internal */\nclass FluidTransform extends FluidValue<string> {\n  protected _value: string | null = null\n\n  constructor(\n    readonly inputs: Inputs,\n    readonly transforms: Transforms\n  ) {\n    super()\n  }\n\n  get() {\n    return this._value || (this._value = this._get())\n  }\n\n  protected _get() {\n    let transform = ''\n    let identity = true\n    each(this.inputs, (input, i) => {\n      const arg1 = getFluidValue(input[0])\n      const [t, id] = this.transforms[i](\n        is.arr(arg1) ? arg1 : input.map(getFluidValue)\n      )\n      transform += ' ' + t\n      identity = identity && id\n    })\n    return identity ? 'none' : transform\n  }\n\n  // Start observing our inputs once we have an observer.\n  protected observerAdded(count: number) {\n    if (count == 1)\n      each(this.inputs, input =>\n        each(\n          input,\n          value => hasFluidValue(value) && addFluidObserver(value, this)\n        )\n      )\n  }\n\n  // Stop observing our inputs once we have no observers.\n  protected observerRemoved(count: number) {\n    if (count == 0)\n      each(this.inputs, input =>\n        each(\n          input,\n          value => hasFluidValue(value) && removeFluidObserver(value, this)\n        )\n      )\n  }\n\n  eventObserved(event: FluidEvent) {\n    if (event.type == 'change') {\n      this._value = null\n    }\n    callFluidObservers(this, event)\n  }\n}\n", "export type Primitives = keyof JSX.IntrinsicElements\nexport const primitives: Primitives[] = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  // SVG\n  'circle',\n  'clipPath',\n  'defs',\n  'ellipse',\n  'foreignObject',\n  'g',\n  'image',\n  'line',\n  'linearGradient',\n  'mask',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialGradient',\n  'rect',\n  'stop',\n  'svg',\n  'text',\n  'tspan',\n]\n", "import { timeFormat } from 'd3-time-format'\nimport { format as d3Format } from 'd3-format'\n// @ts-ignore\nimport { textPropsByEngine } from '@nivo/core'\nimport { ScaleValue, AnyScale, TicksSpec, getScaleTicks, centerScale } from '@nivo/scales'\nimport { Point, ValueFormatter, Line } from './types'\n\nconst isArray = <T>(value: unknown): value is T[] => Array.isArray(value)\n\nexport const computeCartesianTicks = <Value extends ScaleValue>({\n    axis,\n    scale,\n    ticksPosition,\n    tickValues,\n    tickSize,\n    tickPadding,\n    tickRotation,\n    truncateTickAt,\n    engine = 'svg',\n}: {\n    axis: 'x' | 'y'\n    scale: AnyScale\n    ticksPosition?: 'after' | 'before'\n    tickValues?: TicksSpec<Value>\n    tickSize: number\n    tickPadding: number\n    tickRotation: number\n    truncateTickAt?: number\n    engine?: 'svg' | 'canvas'\n}) => {\n    const values = getScaleTicks<Value>(scale, tickValues)\n\n    const textProps = textPropsByEngine[engine]\n\n    const position = 'bandwidth' in scale ? centerScale(scale) : scale\n    const line = { lineX: 0, lineY: 0 }\n    const text = { textX: 0, textY: 0 }\n\n    const isRTL = typeof document === 'object' ? document.dir === 'rtl' : false\n    let translate: (value: Value) => Point\n    let textAlign: CanvasTextAlign = textProps.align.center\n    let textBaseline: CanvasTextBaseline = textProps.baseline.center\n\n    if (axis === 'x') {\n        translate = d => ({ x: position(d) ?? 0, y: 0 })\n\n        line.lineY = tickSize * (ticksPosition === 'after' ? 1 : -1)\n        text.textY = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1)\n\n        if (ticksPosition === 'after') {\n            textBaseline = textProps.baseline.top\n        } else {\n            textBaseline = textProps.baseline.bottom\n        }\n\n        if (tickRotation === 0) {\n            textAlign = textProps.align.center\n        } else if (\n            (ticksPosition === 'after' && tickRotation < 0) ||\n            (ticksPosition === 'before' && tickRotation > 0)\n        ) {\n            textAlign = textProps.align[isRTL ? 'left' : 'right']\n            textBaseline = textProps.baseline.center\n        } else if (\n            (ticksPosition === 'after' && tickRotation > 0) ||\n            (ticksPosition === 'before' && tickRotation < 0)\n        ) {\n            textAlign = textProps.align[isRTL ? 'right' : 'left']\n            textBaseline = textProps.baseline.center\n        }\n    } else {\n        translate = d => ({ x: 0, y: position(d) ?? 0 })\n\n        line.lineX = tickSize * (ticksPosition === 'after' ? 1 : -1)\n        text.textX = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1)\n\n        if (ticksPosition === 'after') {\n            textAlign = textProps.align.left\n        } else {\n            textAlign = textProps.align.right\n        }\n    }\n\n    const truncateTick = (value: string) => {\n        const valueLength = String(value).length\n\n        if (truncateTickAt && truncateTickAt > 0 && valueLength > truncateTickAt) {\n            return `${String(value).slice(0, truncateTickAt).concat('...')}`\n        }\n        return `${value}`\n    }\n\n    const ticks = values.map((value: Value) => {\n        const processedValue =\n            typeof value === 'string' ? (truncateTick(value) as unknown as Value) : value\n        return {\n            key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n            value: processedValue,\n            ...translate(value),\n            ...line,\n            ...text,\n        }\n    })\n\n    return {\n        ticks,\n        textAlign,\n        textBaseline,\n    }\n}\n\nexport const getFormatter = <Value extends ScaleValue>(\n    format: string | ValueFormatter<Value> | undefined,\n    scale: AnyScale\n): ValueFormatter<Value> | undefined => {\n    if (typeof format === 'undefined' || typeof format === 'function') return format\n\n    if (scale.type === 'time') {\n        const formatter = timeFormat(format)\n\n        return ((d: any) => formatter(d instanceof Date ? d : new Date(d))) as ValueFormatter<Value>\n    }\n\n    return d3Format(format) as unknown as ValueFormatter<Value>\n}\n\nexport const computeGridLines = <Value extends ScaleValue>({\n    width,\n    height,\n    scale,\n    axis,\n    values: _values,\n}: {\n    width: number\n    height: number\n    scale: AnyScale\n    axis: 'x' | 'y'\n    values?: TicksSpec<Value>\n}) => {\n    const lineValues = isArray<number>(_values) ? _values : undefined\n    const values = lineValues || getScaleTicks<Value>(scale, _values)\n    const position = 'bandwidth' in scale ? centerScale(scale) : scale\n\n    const lines: Line[] =\n        axis === 'x'\n            ? values.map((value: Value) => ({\n                  key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n                  x1: position(value) ?? 0,\n                  x2: position(value) ?? 0,\n                  y1: 0,\n                  y2: height,\n              }))\n            : values.map((value: Value) => ({\n                  key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n                  x1: 0,\n                  x2: width,\n                  y1: position(value) ?? 0,\n                  y2: position(value) ?? 0,\n              }))\n\n    return lines\n}\n", "import { useMemo, memo } from 'react'\nimport * as React from 'react'\nimport { animated } from '@react-spring/web'\nimport { useTheme, sanitizeSvgTextStyle } from '@nivo/core'\nimport { ScaleValue } from '@nivo/scales'\nimport { AxisTickProps } from '../types'\n\nconst AxisTick = <Value extends ScaleValue>({\n    value: _value,\n    format,\n    lineX,\n    lineY,\n    onClick,\n    textBaseline,\n    textAnchor,\n    animatedProps,\n}: AxisTickProps<Value>) => {\n    const theme = useTheme()\n    const lineStyle = theme.axis.ticks.line\n    const textStyle = theme.axis.ticks.text\n\n    const value = format?.(_value) ?? _value\n\n    const props = useMemo(() => {\n        const style = { opacity: animatedProps.opacity }\n\n        if (!onClick) {\n            return { style }\n        }\n\n        return {\n            style: { ...style, cursor: 'pointer' },\n            onClick: (event: React.MouseEvent<SVGGElement, MouseEvent>) => onClick(event, value),\n        }\n    }, [animatedProps.opacity, onClick, value])\n\n    return (\n        <animated.g transform={animatedProps.transform} {...props}>\n            <line x1={0} x2={lineX} y1={0} y2={lineY} style={lineStyle} />\n            {textStyle.outlineWidth > 0 && (\n                <animated.text\n                    dominantBaseline={textBaseline}\n                    textAnchor={textAnchor}\n                    transform={animatedProps.textTransform}\n                    style={textStyle}\n                    strokeWidth={textStyle.outlineWidth * 2}\n                    stroke={textStyle.outlineColor}\n                    strokeLinejoin=\"round\"\n                >\n                    {`${value}`}\n                </animated.text>\n            )}\n            <animated.text\n                dominantBaseline={textBaseline}\n                textAnchor={textAnchor}\n                transform={animatedProps.textTransform}\n                style={sanitizeSvgTextStyle(textStyle)}\n            >\n                {`${value}`}\n            </animated.text>\n        </animated.g>\n    )\n}\n\nconst memoizedAxisTick = memo(AxisTick) as typeof AxisTick\n\nexport { memoizedAxisTick as AxisTick }\n", "import { useMotionConfig, useTheme } from '@nivo/core'\nimport { AnyScale, ScaleValue } from '@nivo/scales'\nimport { animated, useSpring, useTransition } from '@react-spring/web'\nimport * as React from 'react'\nimport { memo, useCallback, useMemo } from 'react'\nimport { computeCartesianTicks, getFormatter } from '../compute'\nimport { AxisProps } from '../types'\nimport { AxisTick } from './AxisTick'\n\nexport const NonMemoizedAxis = <Value extends ScaleValue>({\n    axis,\n    scale,\n    x = 0,\n    y = 0,\n    length,\n    ticksPosition,\n    tickValues,\n    tickSize = 5,\n    tickPadding = 5,\n    tickRotation = 0,\n    format,\n    renderTick = AxisTick,\n    truncateTickAt,\n    legend,\n    legendPosition = 'end',\n    legendOffset = 0,\n    onClick,\n    ariaHidden,\n}: AxisProps<Value> & {\n    axis: 'x' | 'y'\n    scale: AnyScale\n    x?: number\n    y?: number\n    length: number\n    onClick?: (event: React.MouseEvent<SVGGElement, MouseEvent>, value: Value | string) => void\n}) => {\n    const theme = useTheme()\n    const legendTextStyle = theme.axis.legend.text\n\n    const formatValue = useMemo(() => getFormatter(format, scale), [format, scale])\n\n    const { ticks, textAlign, textBaseline } = computeCartesianTicks({\n        axis,\n        scale,\n        ticksPosition,\n        tickValues,\n        tickSize,\n        tickPadding,\n        tickRotation,\n        truncateTickAt,\n    })\n\n    let legendNode = null\n    if (legend !== undefined) {\n        let legendX = 0\n        let legendY = 0\n        let legendRotation = 0\n        let textAnchor\n\n        if (axis === 'y') {\n            legendRotation = -90\n            legendX = legendOffset\n            if (legendPosition === 'start') {\n                textAnchor = 'start'\n                legendY = length\n            } else if (legendPosition === 'middle') {\n                textAnchor = 'middle'\n                legendY = length / 2\n            } else if (legendPosition === 'end') {\n                textAnchor = 'end'\n            }\n        } else {\n            legendY = legendOffset\n            if (legendPosition === 'start') {\n                textAnchor = 'start'\n            } else if (legendPosition === 'middle') {\n                textAnchor = 'middle'\n                legendX = length / 2\n            } else if (legendPosition === 'end') {\n                textAnchor = 'end'\n                legendX = length\n            }\n        }\n\n        legendNode = (\n            <>\n                {legendTextStyle.outlineWidth > 0 && (\n                    <text\n                        transform={`translate(${legendX}, ${legendY}) rotate(${legendRotation})`}\n                        textAnchor={textAnchor}\n                        style={{\n                            dominantBaseline: 'central',\n                            ...legendTextStyle,\n                        }}\n                        strokeWidth={legendTextStyle.outlineWidth * 2}\n                        stroke={legendTextStyle.outlineColor}\n                        strokeLinejoin=\"round\"\n                    >\n                        {legend}\n                    </text>\n                )}\n                <text\n                    transform={`translate(${legendX}, ${legendY}) rotate(${legendRotation})`}\n                    textAnchor={textAnchor}\n                    style={{\n                        dominantBaseline: 'central',\n                        ...legendTextStyle,\n                    }}\n                >\n                    {legend}\n                </text>\n            </>\n        )\n    }\n\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        transform: `translate(${x},${y})`,\n        lineX2: axis === 'x' ? length : 0,\n        lineY2: axis === 'x' ? 0 : length,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    const getAnimatedProps = useCallback(\n        (tick: (typeof ticks)[0]) => {\n            return {\n                opacity: 1,\n                transform: `translate(${tick.x},${tick.y})`,\n                textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n            }\n        },\n        [tickRotation]\n    )\n    const getFromAnimatedProps = useCallback(\n        (tick: (typeof ticks)[0]) => ({\n            opacity: 0,\n            transform: `translate(${tick.x},${tick.y})`,\n            textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n        }),\n        [tickRotation]\n    )\n\n    const transition = useTransition<\n        (typeof ticks)[0],\n        { opacity: number; transform: string; textTransform: string }\n    >(ticks, {\n        keys: tick => tick.key,\n        initial: getAnimatedProps,\n        from: getFromAnimatedProps,\n        enter: getAnimatedProps,\n        update: getAnimatedProps,\n        leave: {\n            opacity: 0,\n        },\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.g transform={animatedProps.transform} aria-hidden={ariaHidden}>\n            {transition((transitionProps, tick, _state, tickIndex) => {\n                return React.createElement(renderTick, {\n                    tickIndex,\n                    format: formatValue,\n                    rotate: tickRotation,\n                    textBaseline,\n                    textAnchor: textAlign,\n                    truncateTickAt: truncateTickAt,\n                    animatedProps: transitionProps,\n                    ...tick,\n                    ...(onClick ? { onClick } : {}),\n                })\n            })}\n            <animated.line\n                style={theme.axis.domain.line}\n                x1={0}\n                x2={animatedProps.lineX2}\n                y1={0}\n                y2={animatedProps.lineY2}\n            />\n            {legendNode}\n        </animated.g>\n    )\n}\n\nexport const Axis = memo(NonMemoizedAxis) as typeof NonMemoizedAxis\n", "export const positions = ['top', 'right', 'bottom', 'left'] as const\n", "import { memo } from 'react'\nimport { ScaleValue, AnyScale } from '@nivo/scales'\nimport { Axis } from './Axis'\nimport { positions } from '../props'\nimport { AxisProps } from '../types'\n\nexport const Axes = memo(\n    <X extends ScaleValue, Y extends ScaleValue>({\n        xScale,\n        yScale,\n        width,\n        height,\n        top,\n        right,\n        bottom,\n        left,\n    }: {\n        xScale: AnyScale\n        yScale: AnyScale\n        width: number\n        height: number\n        top?: AxisProps<X> | null\n        right?: AxisProps<Y> | null\n        bottom?: AxisProps<X> | null\n        left?: AxisProps<Y> | null\n    }) => {\n        const axes = { top, right, bottom, left }\n\n        return (\n            <>\n                {positions.map(position => {\n                    const axis = axes[position] as typeof position extends 'bottom' | 'top'\n                        ? AxisProps<X> | undefined\n                        : AxisProps<Y> | undefined\n\n                    if (!axis) return null\n\n                    const isXAxis = position === 'top' || position === 'bottom'\n                    const ticksPosition =\n                        position === 'top' || position === 'left' ? 'before' : 'after'\n\n                    return (\n                        <Axis\n                            key={position}\n                            {...axis}\n                            axis={isXAxis ? 'x' : 'y'}\n                            x={position === 'right' ? width : 0}\n                            y={position === 'bottom' ? height : 0}\n                            scale={isXAxis ? xScale : yScale}\n                            length={isXAxis ? width : height}\n                            ticksPosition={ticksPosition}\n                            truncateTickAt={axis.truncateTickAt}\n                        />\n                    )\n                })}\n            </>\n        )\n    }\n)\n", "import { memo, SVGAttributes } from 'react'\nimport { SpringValues, animated } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\n\nexport const GridLine = memo(\n    ({\n        animatedProps,\n    }: {\n        animatedProps: SpringValues<{\n            opacity: number\n            x1: number\n            x2: number\n            y1: number\n            y2: number\n        }>\n    }) => {\n        const theme = useTheme()\n\n        return (\n            <animated.line\n                {...animatedProps}\n                {...(theme.grid.line as SVGAttributes<SVGLineElement>)}\n            />\n        )\n    }\n)\n", "import { memo } from 'react'\nimport { useTransition } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { GridLine } from './GridLine'\nimport { Line } from '../types'\n\nexport const GridLines = memo(({ lines }: { lines: Line[] }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const transition = useTransition<Line, Record<'opacity' | 'x1' | 'x2' | 'y1' | 'y2', number>>(\n        lines,\n        {\n            keys: line => line.key,\n            initial: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            from: line => ({\n                opacity: 0,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            enter: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            update: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            leave: {\n                opacity: 0,\n            },\n            config: springConfig,\n            immediate: !animate,\n        }\n    )\n\n    return (\n        <g>\n            {transition((animatedProps, line) => (\n                <GridLine {...line} key={line.key} animatedProps={animatedProps} />\n            ))}\n        </g>\n    )\n})\n", "import { useMemo, memo } from 'react'\nimport { ScaleValue, AnyScale, TicksSpec } from '@nivo/scales'\nimport { GridLines } from './GridLines'\nimport { computeGridLines } from '../compute'\n\nexport const Grid = memo(\n    <X extends ScaleValue, Y extends ScaleValue>({\n        width,\n        height,\n        xScale,\n        yScale,\n        xValues,\n        yValues,\n    }: {\n        width: number\n        height: number\n        xScale?: AnyScale | null\n        xValues?: TicksSpec<X>\n        yScale?: AnyScale | null\n        yValues?: TicksSpec<Y>\n    }) => {\n        const xLines = useMemo(() => {\n            if (!xScale) return false\n\n            return computeGridLines({\n                width,\n                height,\n                scale: xScale,\n                axis: 'x',\n                values: xValues,\n            })\n        }, [xScale, xValues, width, height])\n\n        const yLines = useMemo(() => {\n            if (!yScale) return false\n\n            return computeGridLines({\n                width,\n                height,\n                scale: yScale,\n                axis: 'y',\n                values: yValues,\n            })\n        }, [height, width, yScale, yValues])\n\n        return (\n            <>\n                {xLines && <GridLines lines={xLines} />}\n                {yLines && <GridLines lines={yLines} />}\n            </>\n        )\n    }\n)\n", "import { degreesToRadians, CompleteTheme } from '@nivo/core'\nimport { ScaleValue, AnyScale, TicksSpec } from '@nivo/scales'\nimport { computeCartesianTicks, getFormatter, computeGridLines } from './compute'\nimport { positions } from './props'\nimport { AxisLegendPosition, CanvasAxisProps, ValueFormatter } from './types'\n\nexport const renderAxisToCanvas = <Value extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        axis,\n        scale,\n        x = 0,\n        y = 0,\n        length,\n\n        ticksPosition,\n        tickValues,\n        tickSize = 5,\n        tickPadding = 5,\n        tickRotation = 0,\n        format: _format,\n\n        legend,\n        legendPosition = 'end',\n        legendOffset = 0,\n\n        theme,\n    }: {\n        axis: 'x' | 'y'\n        scale: AnyScale\n        x?: number\n        y?: number\n        length: number\n        ticksPosition: 'before' | 'after'\n        tickValues?: TicksSpec<Value>\n        tickSize?: number\n        tickPadding?: number\n        tickRotation?: number\n        format?: string | ValueFormatter<Value>\n        legend?: string\n        legendPosition?: AxisLegendPosition\n        legendOffset?: number\n        theme: CompleteTheme\n    }\n) => {\n    const { ticks, textAlign, textBaseline } = computeCartesianTicks({\n        axis,\n        scale,\n        ticksPosition,\n        tickValues,\n        tickSize,\n        tickPadding,\n        tickRotation,\n        engine: 'canvas',\n    })\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.textAlign = textAlign\n    ctx.textBaseline = textBaseline\n\n    const textStyle = theme.axis.ticks.text\n    ctx.font = `${textStyle.fontWeight ? `${textStyle.fontWeight} ` : ''}${textStyle.fontSize}px ${\n        textStyle.fontFamily\n    }`\n\n    if ((theme.axis.domain.line.strokeWidth ?? 0) > 0) {\n        ctx.lineWidth = Number(theme.axis.domain.line.strokeWidth)\n        ctx.lineCap = 'square'\n\n        if (theme.axis.domain.line.stroke) {\n            ctx.strokeStyle = theme.axis.domain.line.stroke\n        }\n\n        ctx.beginPath()\n        ctx.moveTo(0, 0)\n        ctx.lineTo(axis === 'x' ? length : 0, axis === 'x' ? 0 : length)\n        ctx.stroke()\n    }\n\n    const format = typeof _format === 'function' ? _format : (value: unknown) => `${value}`\n\n    ticks.forEach(tick => {\n        if ((theme.axis.ticks.line.strokeWidth ?? 0) > 0) {\n            ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth)\n            ctx.lineCap = 'square'\n\n            if (theme.axis.ticks.line.stroke) {\n                ctx.strokeStyle = theme.axis.ticks.line.stroke\n            }\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x, tick.y)\n            ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY)\n            ctx.stroke()\n        }\n\n        const value = format(tick.value)\n\n        ctx.save()\n        ctx.translate(tick.x + tick.textX, tick.y + tick.textY)\n        ctx.rotate(degreesToRadians(tickRotation))\n\n        if (textStyle.outlineWidth > 0) {\n            ctx.strokeStyle = textStyle.outlineColor\n            ctx.lineWidth = textStyle.outlineWidth * 2\n            ctx.lineJoin = 'round'\n            ctx.strokeText(`${value}`, 0, 0)\n        }\n\n        if (theme.axis.ticks.text.fill) {\n            ctx.fillStyle = textStyle.fill\n        }\n\n        ctx.fillText(`${value}`, 0, 0)\n        ctx.restore()\n    })\n\n    if (legend !== undefined) {\n        let legendX = 0\n        let legendY = 0\n        let legendRotation = 0\n        let textAlign: CanvasTextAlign = 'center'\n\n        if (axis === 'y') {\n            legendRotation = -90\n            legendX = legendOffset\n            if (legendPosition === 'start') {\n                textAlign = 'start'\n                legendY = length\n            } else if (legendPosition === 'middle') {\n                textAlign = 'center'\n                legendY = length / 2\n            } else if (legendPosition === 'end') {\n                textAlign = 'end'\n            }\n        } else {\n            legendY = legendOffset\n            if (legendPosition === 'start') {\n                textAlign = 'start'\n            } else if (legendPosition === 'middle') {\n                textAlign = 'center'\n                legendX = length / 2\n            } else if (legendPosition === 'end') {\n                textAlign = 'end'\n                legendX = length\n            }\n        }\n\n        ctx.translate(legendX, legendY)\n        ctx.rotate(degreesToRadians(legendRotation))\n        ctx.font = `${\n            theme.axis.legend.text.fontWeight ? `${theme.axis.legend.text.fontWeight} ` : ''\n        }${theme.axis.legend.text.fontSize}px ${theme.axis.legend.text.fontFamily}`\n\n        if (theme.axis.legend.text.fill) {\n            ctx.fillStyle = theme.axis.legend.text.fill\n        }\n\n        ctx.textAlign = textAlign\n        ctx.textBaseline = 'middle'\n        ctx.fillText(legend, 0, 0)\n    }\n\n    ctx.restore()\n}\n\nexport const renderAxesToCanvas = <X extends ScaleValue, Y extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        xScale,\n        yScale,\n        width,\n        height,\n\n        top,\n        right,\n        bottom,\n        left,\n\n        theme,\n    }: {\n        xScale: AnyScale\n        yScale: AnyScale\n        width: number\n        height: number\n        top?: CanvasAxisProps<X> | null\n        right?: CanvasAxisProps<Y> | null\n        bottom?: CanvasAxisProps<X> | null\n        left?: CanvasAxisProps<Y> | null\n        theme: CompleteTheme\n    }\n) => {\n    const axes = { top, right, bottom, left }\n\n    positions.forEach(position => {\n        const axis = axes[position] as typeof position extends 'bottom' | 'top'\n            ? CanvasAxisProps<X> | undefined\n            : CanvasAxisProps<Y> | undefined\n\n        if (!axis) return null\n\n        const isXAxis = position === 'top' || position === 'bottom'\n        const ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after'\n        const scale = isXAxis ? xScale : yScale\n        const format = getFormatter(axis.format, scale)\n\n        renderAxisToCanvas(ctx, {\n            ...axis,\n            axis: isXAxis ? 'x' : 'y',\n            x: position === 'right' ? width : 0,\n            y: position === 'bottom' ? height : 0,\n            scale,\n            format,\n            length: isXAxis ? width : height,\n            ticksPosition,\n            theme,\n        })\n    })\n}\n\nexport const renderGridLinesToCanvas = <Value extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        width,\n        height,\n        scale,\n        axis,\n        values,\n    }: {\n        width: number\n        height: number\n        scale: AnyScale\n        axis: 'x' | 'y'\n        values?: TicksSpec<Value>\n    }\n) => {\n    const lines = computeGridLines({ width, height, scale, axis, values })\n\n    lines.forEach(line => {\n        ctx.beginPath()\n        ctx.moveTo(line.x1, line.y1)\n        ctx.lineTo(line.x2, line.y2)\n        ctx.stroke()\n    })\n}\n"],
  "mappings": "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",
  "names": []
}
