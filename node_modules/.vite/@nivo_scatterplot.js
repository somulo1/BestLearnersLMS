import {
  H as H2,
  I,
  W,
  z as z2
} from "./chunk-FGKQM6BC.js";
import {
  J,
  R,
  S
} from "./chunk-P6YTOCWM.js";
import {
  B,
  C,
  dn,
  j,
  z
} from "./chunk-JTYFOI3S.js";
import "./chunk-B545YG5G.js";
import {
  H,
  O
} from "./chunk-5CPLXP24.js";
import {
  pr
} from "./chunk-LIF42OKE.js";
import {
  require_isNumber
} from "./chunk-6YWBRFZ4.js";
import "./chunk-SY6HMO6G.js";
import "./chunk-AD5TROZ4.js";
import "./chunk-6JM3GFV6.js";
import "./chunk-DZU3R4ZD.js";
import "./chunk-3T4KNB5M.js";
import "./chunk-NIFAYVBJ.js";
import {
  It,
  Ot,
  Rn,
  Sn,
  St,
  Ur,
  Wn,
  gn,
  jn,
  k,
  require_jsx_runtime,
  w,
  wt,
  zt
} from "./chunk-CIEVK6OE.js";
import {
  AnimatedObject,
  FluidValue,
  addFluidObserver,
  callFluidObservers,
  colors2,
  createHost,
  createStringInterpolator2,
  each,
  eachProp,
  getFluidValue,
  globals_exports,
  hasFluidValue,
  is,
  removeFluidObserver,
  toArray,
  useTransition
} from "./chunk-UROOLUEL.js";
import {
  linear,
  require_isString
} from "./chunk-JMENM4FH.js";
import {
  require_get,
  require_isPlainObject
} from "./chunk-B7PIYN4Z.js";
import "./chunk-V2CXUUTH.js";
import {
  require_react_dom
} from "./chunk-2J4CPGJC.js";
import "./chunk-SEBMSOEZ.js";
import {
  require_react
} from "./chunk-3HGGCXHU.js";
import {
  __objRest,
  __toModule
} from "./chunk-AXQKKFRM.js";

// node_modules/@nivo/scatterplot/dist/nivo-scatterplot.es.js
var import_react = __toModule(require_react());
var import_get = __toModule(require_get());
var import_isString = __toModule(require_isString());
var import_isNumber = __toModule(require_isNumber());
var import_isPlainObject = __toModule(require_isPlainObject());

// node_modules/@nivo/scatterplot/node_modules/@react-spring/web/dist/react-spring_web.legacy-esm.js
var import_react_dom = __toModule(require_react_dom());
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const _a = props, {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox
  } = _a, attributes = __objRest(_a, [
    "className",
    "style",
    "children",
    "scrollTop",
    "scrollLeft",
    "viewBox"
  ]);
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase())));
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i2) => {
    instance.setAttribute(name, values[i2]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor(_a) {
    var _b = _a, { x, y, z: z3 } = _b, style = __objRest(_b, ["x", "y", "z"]);
    const inputs = [];
    const transforms = [];
    if (x || y || z3) {
      inputs.push([x || 0, y || 0, z3 || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(key === "rotate3d" ? ([x2, y2, z22, deg]) => [
          `rotate3d(${x2},${y2},${z22},${addUnit(deg, unit)})`,
          isValueIdentity(deg, 0)
        ] : (input) => [
          `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
          isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
        ]);
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i2) => {
      const arg1 = getFluidValue(input[0]);
      const [t2, id] = this.transforms[i2](is.arr(arg1) ? arg1 : input.map(getFluidValue));
      transform += " " + t2;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  observerAdded(count) {
    if (count == 1)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
  }
  observerRemoved(count) {
    if (count == 0)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  getComponentProps: (_a) => {
    var _b = _a, { scrollTop, scrollLeft } = _b, props = __objRest(_b, ["scrollTop", "scrollLeft"]);
    return props;
  }
});
var animated = host.animated;

// node_modules/@nivo/scatterplot/dist/nivo-scatterplot.es.js
var import_jsx_runtime = __toModule(require_jsx_runtime());
function A() {
  return A = Object.assign ? Object.assign.bind() : function(e2) {
    for (var n2 = 1; n2 < arguments.length; n2++) {
      var o2 = arguments[n2];
      for (var i2 in o2)
        Object.prototype.hasOwnProperty.call(o2, i2) && (e2[i2] = o2[i2]);
    }
    return e2;
  }, A.apply(this, arguments);
}
function U(e2, n2) {
  if (e2 == null)
    return {};
  var o2, i2, t2 = {}, r2 = Object.keys(e2);
  for (i2 = 0; i2 < r2.length; i2++)
    o2 = r2[i2], n2.indexOf(o2) >= 0 || (t2[o2] = e2[o2]);
  return t2;
}
var q = function(e2) {
  if (typeof e2 == "function")
    return e2;
  if ((0, import_isNumber.default)(e2))
    return function() {
      return e2;
    };
  if (function(e3) {
    return (0, import_isPlainObject.default)(e3);
  }(e2)) {
    if (!(0, import_isString.default)(e2.key))
      throw new Error("symbolSize is invalid, key should be a string pointing to the property to use to determine node size");
    if (!Array.isArray(e2.values) || e2.values.length !== 2)
      throw new Error("symbolSize is invalid, values spec should be an array containing two values, min and max");
    if (!Array.isArray(e2.sizes) || e2.sizes.length !== 2)
      throw new Error("symbolSize is invalid, sizes spec should be an array containing two values, min and max");
    var n2 = linear().domain([e2.values[0], e2.values[1]]).range([e2.sizes[0], e2.sizes[1]]);
    return function(o2) {
      return n2((0, import_get.default)(o2, e2.key));
    };
  }
  throw new Error("nodeSize is invalid, it should be either a function, a number or an object");
};
var J2 = function(n2) {
  var o2, i2 = n2.data, t2 = n2.xScaleSpec, r2 = n2.xFormat, a2 = n2.yScaleSpec, d2 = n2.yFormat, u = n2.width, c = n2.height, h = n2.nodeId, f = n2.nodeSize, v = n2.colors, m = (0, import_react.useMemo)(function() {
    return dn(i2, t2, a2, u, c);
  }, [i2, t2, a2, u, c]), g = m.series, p = m.xScale, y = m.yScale, x = Ot(r2), M = Ot(d2), S2 = Wn(h), b = (0, import_react.useMemo)(function() {
    return function(e2) {
      var n3 = e2.series, o3 = e2.formatX, i3 = e2.formatY, t3 = e2.getNodeId, r3 = [];
      return n3.forEach(function(e3) {
        e3.data.forEach(function(n4, a3) {
          var d3 = { index: r3.length, serieIndex: a3, serieId: e3.id, x: n4.position.x, xValue: n4.data.x, formattedX: o3(n4.data.x), y: n4.position.y, yValue: n4.data.y, formattedY: i3(n4.data.y), data: n4.data };
          r3.push(A({}, d3, { id: t3(d3) }));
        });
      }), r3;
    }({ series: g, formatX: x, formatY: M, getNodeId: S2 });
  }, [g, x, M, S2]), w2 = (0, import_react.useMemo)(function() {
    return q(o2);
  }, [o2 = f]), I2 = pr(v, "serieId");
  return { xScale: p, yScale: y, nodes: (0, import_react.useMemo)(function() {
    return b.map(function(e2) {
      return A({}, e2, { size: w2(e2), color: I2({ serieId: e2.serieId }) });
    });
  }, [b, w2, I2]), legendData: (0, import_react.useMemo)(function() {
    return g.map(function(e2) {
      return { id: e2.id, label: e2.id, color: I2({ serieId: e2.id }) };
    });
  }, [g, I2]) };
};
var K = function(e2, n2) {
  return S({ data: e2, annotations: n2, getPosition: function(e3) {
    return { x: e3.x, y: e3.y };
  }, getDimensions: function(e3) {
    return { size: e3.size, width: e3.size, height: e3.size };
  } });
};
var Q = function(e2) {
  return e2 / 2;
};
var Z = { xScale: { type: "linear", min: 0, max: "auto" }, yScale: { type: "linear", min: 0, max: "auto" }, enableGridX: true, enableGridY: true, axisBottom: {}, axisLeft: {}, nodeId: function(e2) {
  return e2.serieId + "." + e2.index;
}, nodeSize: 9, nodeComponent: function(e2) {
  var o2 = e2.node, i2 = e2.style, t2 = e2.blendMode, r2 = e2.isInteractive, a2 = e2.onMouseEnter, d2 = e2.onMouseMove, s = e2.onMouseLeave, l = e2.onClick, u = (0, import_react.useCallback)(function(e3) {
    return a2 == null ? void 0 : a2(o2, e3);
  }, [o2, a2]), c = (0, import_react.useCallback)(function(e3) {
    return d2 == null ? void 0 : d2(o2, e3);
  }, [o2, d2]), h = (0, import_react.useCallback)(function(e3) {
    return s == null ? void 0 : s(o2, e3);
  }, [o2, s]), f = (0, import_react.useCallback)(function(e3) {
    return l == null ? void 0 : l(o2, e3);
  }, [o2, l]);
  return (0, import_jsx_runtime.jsx)(animated.circle, { cx: i2.x, cy: i2.y, r: i2.size.to(Q), fill: i2.color, style: { mixBlendMode: t2 }, onMouseEnter: r2 ? u : void 0, onMouseMove: r2 ? c : void 0, onMouseLeave: r2 ? h : void 0, onClick: r2 ? f : void 0 });
}, colors: { scheme: "nivo" }, isInteractive: true, debugMesh: false, tooltip: function(e2) {
  var n2 = e2.node;
  return (0, import_jsx_runtime.jsx)(w, { id: n2.serieId, value: "x: " + n2.formattedX + ", y: " + n2.formattedY, enableChip: true, color: n2.color });
}, markers: [], legends: [], annotations: [] };
var $ = A({}, Z, { blendMode: "normal", layers: ["grid", "axes", "nodes", "markers", "mesh", "legends", "annotations"], role: "img", useMesh: true, animate: true, motionConfig: "default" });
var _ = A({}, Z, { layers: ["grid", "axes", "nodes", "mesh", "legends", "annotations"], pixelRatio: typeof window != "undefined" && window.devicePixelRatio || 1, renderNode: function(e2, n2) {
  e2.beginPath(), e2.arc(n2.x, n2.y, n2.size / 2, 0, 2 * Math.PI), e2.fillStyle = n2.color, e2.fill();
} });
var ee = function(e2) {
  var n2 = e2.nodes, o2 = e2.annotations, i2 = K(n2, o2);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: i2.map(function(e3, n3) {
    return (0, import_jsx_runtime.jsx)(R, A({}, e3), n3);
  }) });
};
var ne = function(e2) {
  return e2.id;
};
var oe = function(e2) {
  return { x: e2.x, y: e2.y, size: e2.size, color: e2.color };
};
var ie = function(e2) {
  return { x: e2.x, y: e2.y, size: 0, color: e2.color };
};
var te = function(e2) {
  var i2 = e2.nodes, t2 = e2.nodeComponent, r2 = e2.isInteractive, a2 = e2.onMouseEnter, d2 = e2.onMouseMove, s = e2.onMouseLeave, l = e2.onClick, c = e2.tooltip, h = e2.blendMode, f = Ur(), v = f.animate, m = f.config, g = useTransition(i2, { keys: ne, from: oe, enter: oe, update: oe, leave: ie, config: m, immediate: !v }), p = k(), y = p.showTooltipFromEvent, x = p.hideTooltip, M = (0, import_react.useCallback)(function(e3, n2) {
    y((0, import_react.createElement)(c, { node: e3 }), n2), a2 == null || a2(e3, n2);
  }, [c, y, a2]), S2 = (0, import_react.useCallback)(function(e3, n2) {
    y((0, import_react.createElement)(c, { node: e3 }), n2), d2 == null || d2(e3, n2);
  }, [c, y, d2]), b = (0, import_react.useCallback)(function(e3, n2) {
    x(), s == null || s(e3, n2);
  }, [x, s]), w2 = (0, import_react.useCallback)(function(e3, n2) {
    return l == null ? void 0 : l(e3, n2);
  }, [l]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: g(function(e3, n2) {
    return (0, import_react.createElement)(t2, { node: n2, style: e3, blendMode: h, isInteractive: r2, onMouseEnter: r2 ? M : void 0, onMouseMove: r2 ? S2 : void 0, onMouseLeave: r2 ? b : void 0, onClick: r2 ? w2 : void 0 });
  }) });
};
var re = function(e2) {
  var i2 = e2.nodes, t2 = e2.width, r2 = e2.height, a2 = e2.onMouseEnter, d2 = e2.onMouseMove, s = e2.onMouseLeave, l = e2.onClick, u = e2.tooltip, c = e2.debug, h = k(), f = h.showTooltipFromEvent, v = h.hideTooltip, m = (0, import_react.useCallback)(function(e3, n2) {
    f((0, import_react.createElement)(u, { node: e3 }), n2), a2 && a2(e3, n2);
  }, [f, u, a2]), g = (0, import_react.useCallback)(function(e3, n2) {
    f((0, import_react.createElement)(u, { node: e3 }), n2), d2 && d2(e3, n2);
  }, [f, u, d2]), p = (0, import_react.useCallback)(function(e3, n2) {
    v(), s && s(e3, n2);
  }, [v, s]), y = (0, import_react.useCallback)(function(e3, n2) {
    l && l(e3, n2);
  }, [l]);
  return (0, import_jsx_runtime.jsx)(I, { nodes: i2, width: t2, height: r2, onMouseEnter: m, onMouseMove: g, onMouseLeave: p, onClick: y, debug: c });
};
var ae = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var de = function(n2) {
  var t2 = n2.data, r2 = n2.xScale, a2 = r2 === void 0 ? $.xScale : r2, d2 = n2.xFormat, s = n2.yScale, l = s === void 0 ? $.yScale : s, u = n2.yFormat, c = n2.width, m = n2.height, g = n2.margin, p = n2.layers, y = p === void 0 ? $.layers : p, S2 = n2.colors, b = S2 === void 0 ? $.colors : S2, I2 = n2.blendMode, k2 = I2 === void 0 ? $.blendMode : I2, z3 = n2.nodeId, E = z3 === void 0 ? $.nodeId : z3, C2 = n2.nodeSize, L = C2 === void 0 ? $.nodeSize : C2, W3 = n2.nodeComponent, F2 = W3 === void 0 ? $.nodeComponent : W3, X2 = n2.enableGridX, Y2 = X2 === void 0 ? $.enableGridX : X2, B2 = n2.enableGridY, G = B2 === void 0 ? $.enableGridY : B2, H3 = n2.gridXValues, T2 = n2.gridYValues, V = n2.axisTop, j2 = n2.axisRight, O2 = n2.axisBottom, D = O2 === void 0 ? $.axisBottom : O2, N = n2.axisLeft, P = N === void 0 ? $.axisLeft : N, U2 = n2.annotations, q2 = U2 === void 0 ? $.annotations : U2, K2 = n2.isInteractive, Q2 = K2 === void 0 ? $.isInteractive : K2, Z2 = n2.useMesh, _2 = Z2 === void 0 ? $.useMesh : Z2, ne2 = n2.debugMesh, oe2 = ne2 === void 0 ? $.debugMesh : ne2, ie2 = n2.onMouseEnter, ae2 = n2.onMouseMove, de2 = n2.onMouseLeave, se2 = n2.onClick, le2 = n2.tooltip, ue2 = le2 === void 0 ? $.tooltip : le2, ce2 = n2.markers, he2 = ce2 === void 0 ? $.markers : ce2, fe2 = n2.legends, ve = fe2 === void 0 ? $.legends : fe2, me = n2.role, ge = me === void 0 ? $.role : me, pe = n2.ariaLabel, ye = n2.ariaLabelledBy, xe = n2.ariaDescribedBy, Me = wt(c, m, g), Se = Me.margin, be = Me.innerWidth, we = Me.innerHeight, Ie = Me.outerWidth, ke = Me.outerHeight, ze = J2({ data: t2, xScaleSpec: a2, xFormat: d2, yScaleSpec: l, yFormat: u, width: be, height: we, nodeId: E, nodeSize: L, colors: b }), Ee = ze.xScale, Ce = ze.yScale, Le = ze.nodes, We = ze.legendData, Fe = (0, import_react.useMemo)(function() {
    return { xScale: Ee, yScale: Ce, nodes: Le, margin: Se, innerWidth: be, innerHeight: we, outerWidth: Ie, outerHeight: ke };
  }, [Ee, Ce, Le, Se, be, we, Ie, ke]), Xe = { grid: null, axes: null, nodes: null, markers: null, mesh: null, annotations: null, legends: null };
  return y.includes("grid") && (Xe.grid = (0, import_jsx_runtime.jsx)(C, { width: be, height: we, xScale: Y2 ? Ee : null, yScale: G ? Ce : null, xValues: H3, yValues: T2 }, "grid")), y.includes("axes") && (Xe.axes = (0, import_jsx_runtime.jsx)(B, { xScale: Ee, yScale: Ce, width: be, height: we, top: V, right: j2, bottom: D, left: P }, "axes")), y.includes("nodes") && (Xe.nodes = (0, import_jsx_runtime.jsx)(te, { nodes: Le, nodeComponent: F2, isInteractive: Q2, tooltip: ue2, blendMode: k2, onMouseEnter: ie2, onMouseMove: ae2, onMouseLeave: de2, onClick: se2 }, "nodes")), y.includes("markers") && (Xe.markers = (0, import_jsx_runtime.jsx)(Rn, { markers: he2, width: be, height: we, xScale: Ee, yScale: Ce }, "markers")), y.includes("mesh") && Q2 && _2 && (Xe.mesh = (0, import_jsx_runtime.jsx)(re, { nodes: Le, width: be, height: we, onMouseEnter: ie2, onMouseMove: ae2, onMouseLeave: de2, onClick: se2, tooltip: ue2, debug: oe2 }, "mesh")), y.includes("annotations") && (Xe.annotations = (0, import_jsx_runtime.jsx)(ee, { nodes: Le, annotations: q2 }, "annotations")), y.includes("legends") && (Xe.legends = ve.map(function(e2, n3) {
    return (0, import_jsx_runtime.jsx)(O, A({}, e2, { containerWidth: be, containerHeight: we, data: We }), n3);
  })), (0, import_jsx_runtime.jsx)(gn, { width: Ie, height: ke, margin: Se, role: ge, ariaLabel: pe, ariaLabelledBy: ye, ariaDescribedBy: xe, children: y.map(function(e2, n3) {
    if (typeof e2 == "string" && Xe[e2] !== void 0)
      return Xe[e2];
    if (typeof e2 == "function")
      return (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: (0, import_react.createElement)(e2, Fe) }, n3);
    throw new Error("Unknown layer (" + e2 + ")");
  }) });
};
var se = function(e2) {
  var n2 = e2.isInteractive, o2 = n2 === void 0 ? $.isInteractive : n2, i2 = e2.animate, t2 = i2 === void 0 ? $.animate : i2, r2 = e2.motionConfig, a2 = r2 === void 0 ? $.motionConfig : r2, d2 = e2.theme, s = e2.renderWrapper, l = U(e2, ae);
  return (0, import_jsx_runtime.jsx)(St, { animate: t2, isInteractive: o2, motionConfig: a2, renderWrapper: s, theme: d2, children: (0, import_jsx_runtime.jsx)(de, A({ isInteractive: o2 }, l)) });
};
var le = function(e2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(n2) {
    var o2 = n2.width, i2 = n2.height;
    return (0, import_jsx_runtime.jsx)(se, A({ width: o2, height: i2 }, e2));
  } });
};
var ue = ["isInteractive", "renderWrapper", "theme"];
var ce = function(i2) {
  var t2 = i2.data, s = i2.xScale, l = s === void 0 ? _.xScale : s, u = i2.xFormat, c = i2.yScale, f = c === void 0 ? _.yScale : c, v = i2.yFormat, m = i2.width, x = i2.height, M = i2.margin, w2 = i2.pixelRatio, k2 = w2 === void 0 ? _.pixelRatio : w2, z3 = i2.layers, E = z3 === void 0 ? _.layers : z3, C2 = i2.colors, W3 = C2 === void 0 ? _.colors : C2, F2 = i2.nodeId, X2 = F2 === void 0 ? $.nodeId : F2, Y2 = i2.nodeSize, B2 = Y2 === void 0 ? _.nodeSize : Y2, G = i2.renderNode, H3 = G === void 0 ? _.renderNode : G, T2 = i2.enableGridX, V = T2 === void 0 ? _.enableGridX : T2, O2 = i2.gridXValues, U2 = i2.enableGridY, q2 = U2 === void 0 ? _.enableGridY : U2, Q2 = i2.gridYValues, Z2 = i2.axisTop, ee2 = i2.axisRight, ne2 = i2.axisBottom, oe2 = ne2 === void 0 ? _.axisBottom : ne2, ie2 = i2.axisLeft, te2 = ie2 === void 0 ? _.axisLeft : ie2, re2 = i2.annotations, ae2 = re2 === void 0 ? _.annotations : re2, de2 = i2.isInteractive, se2 = de2 === void 0 ? _.isInteractive : de2, le2 = i2.debugMesh, ue2 = le2 === void 0 ? _.debugMesh : le2, ce2 = i2.onMouseEnter, he2 = i2.onMouseMove, fe2 = i2.onMouseLeave, ve = i2.onClick, me = i2.tooltip, ge = me === void 0 ? _.tooltip : me, pe = i2.legends, ye = pe === void 0 ? _.legends : pe, xe = i2.canvasRef, Me = (0, import_react.useRef)(null), Se = zt(), be = (0, import_react.useState)(null), we = be[0], Ie = be[1], ke = wt(m, x, M), ze = ke.margin, Ee = ke.innerWidth, Ce = ke.innerHeight, Le = ke.outerWidth, We = ke.outerHeight, Fe = J2({ data: t2, xScaleSpec: l, xFormat: u, yScaleSpec: f, yFormat: v, width: Ee, height: Ce, nodeId: X2, nodeSize: B2, colors: W3 }), Xe = Fe.xScale, Ye = Fe.yScale, Be = Fe.nodes, Ge = Fe.legendData, He = K(Be, ae2), Re = W({ points: Be, width: Ee, height: Ce, debug: ue2 }), Te = Re.delaunay, Ve = Re.voronoi, je = (0, import_react.useMemo)(function() {
    return { xScale: Xe, yScale: Ye, nodes: Be, margin: ze, innerWidth: Ee, innerHeight: Ce, outerWidth: Le, outerHeight: We };
  }, [Xe, Ye, Be, ze, Ee, Ce, Le, We]);
  (0, import_react.useEffect)(function() {
    if (Me.current) {
      Me.current.width = Le * k2, Me.current.height = We * k2;
      var e2 = Me.current.getContext("2d");
      e2.scale(k2, k2), e2.fillStyle = Se.background, e2.fillRect(0, 0, Le, We), e2.translate(ze.left, ze.top), E.forEach(function(n2) {
        if (n2 === "grid")
          e2.lineWidth = Se.grid.line.strokeWidth, e2.strokeStyle = Se.grid.line.stroke, V && z(e2, { width: Ee, height: Ce, scale: Xe, axis: "x", values: O2 }), q2 && z(e2, { width: Ee, height: Ce, scale: Ye, axis: "y", values: Q2 });
        else if (n2 === "annotations")
          J(e2, { annotations: He, theme: Se });
        else if (n2 === "axes")
          j(e2, { xScale: Xe, yScale: Ye, width: Ee, height: Ce, top: Z2, right: ee2, bottom: oe2, left: te2, theme: Se });
        else if (n2 === "nodes")
          Be.forEach(function(n3) {
            H3(e2, n3);
          });
        else if (n2 === "mesh")
          ue2 && (z2(e2, Ve), we && H2(e2, Ve, we.index));
        else if (n2 === "legends")
          ye.forEach(function(n3) {
            H(e2, A({}, n3, { data: Ge, containerWidth: Ee, containerHeight: Ce, theme: Se }));
          });
        else {
          if (typeof n2 != "function")
            throw new Error("Invalid layer: " + n2);
          n2(e2, je);
        }
      });
    }
  }, [Me, Ee, Ce, Le, We, ze.top, ze.left, k2, H3, E, je, Se, Xe, Ye, Be, V, q2, Z2, ee2, oe2, te2, ye, Ge, ue2, Ve, we, He]);
  var Oe = k(), De = Oe.showTooltipFromEvent, Ne = Oe.hideTooltip, Pe = (0, import_react.useCallback)(function(e2) {
    var n2 = Sn(Me.current, e2), o2 = n2[0], i3 = n2[1];
    if (!jn(ze.left, ze.top, Ee, Ce, o2, i3))
      return null;
    var t3 = Te.find(o2 - ze.left, i3 - ze.top);
    return Be[t3];
  }, [Me, ze, Ee, Ce, Te]), Ae = (0, import_react.useCallback)(function(e2) {
    var n2 = Pe(e2);
    Ie(n2), n2 ? (De((0, import_react.createElement)(ge, { node: n2 }), e2), we && we.id !== n2.id && (fe2 && fe2(we, e2), ce2 && ce2(n2, e2)), we || ce2 && ce2(n2, e2), he2 && he2(n2, e2)) : (Ne(), we && fe2 && fe2(we, e2));
  }, [Pe, we, Ie, De, Ne, ge, ce2, he2, fe2]), Ue = (0, import_react.useCallback)(function(e2) {
    Ne(), Ie(null), we && fe2 && fe2(we, e2);
  }, [Ne, we, Ie, fe2]), qe = (0, import_react.useCallback)(function(e2) {
    if (ve) {
      var n2 = Pe(e2);
      n2 && ve(n2, e2);
    }
  }, [Pe, ve]);
  return (0, import_jsx_runtime.jsx)("canvas", { ref: function(e2) {
    Me.current = e2, xe && "current" in xe && (xe.current = e2);
  }, width: Le * k2, height: We * k2, style: { width: Le, height: We, cursor: se2 ? "auto" : "normal" }, onMouseEnter: se2 ? Ae : void 0, onMouseMove: se2 ? Ae : void 0, onMouseLeave: se2 ? Ue : void 0, onClick: se2 ? qe : void 0 });
};
var he = (0, import_react.forwardRef)(function(e2, n2) {
  var o2 = e2.isInteractive, i2 = e2.renderWrapper, t2 = e2.theme, r2 = U(e2, ue);
  return (0, import_jsx_runtime.jsx)(St, { isInteractive: o2, renderWrapper: i2, theme: t2, animate: false, children: (0, import_jsx_runtime.jsx)(ce, A({}, r2, { canvasRef: n2 })) });
});
var fe = (0, import_react.forwardRef)(function(e2, n2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(o2) {
    var i2 = o2.width, t2 = o2.height;
    return (0, import_jsx_runtime.jsx)(he, A({ width: i2, height: t2 }, e2, { ref: n2 }));
  } });
});
export {
  le as ResponsiveScatterPlot,
  fe as ResponsiveScatterPlotCanvas,
  se as ScatterPlot,
  he as ScatterPlotCanvas,
  _ as canvasDefaultProps,
  Z as commonDefaultProps,
  $ as svgDefaultProps,
  J2 as useScatterPlot,
  K as useScatterPlotAnnotations
};
//# sourceMappingURL=@nivo_scatterplot.js.map
