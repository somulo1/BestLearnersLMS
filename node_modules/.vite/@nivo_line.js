import {
  H as H2,
  I,
  W,
  z as z2
} from "./chunk-FGKQM6BC.js";
import {
  B,
  C as C2,
  dn,
  j,
  z
} from "./chunk-JTYFOI3S.js";
import "./chunk-B545YG5G.js";
import {
  H,
  O
} from "./chunk-5CPLXP24.js";
import {
  Xe,
  pr
} from "./chunk-LIF42OKE.js";
import "./chunk-SY6HMO6G.js";
import "./chunk-AD5TROZ4.js";
import "./chunk-6JM3GFV6.js";
import "./chunk-DZU3R4ZD.js";
import {
  C,
  Fr,
  In,
  It,
  On,
  Ot,
  P,
  Rn,
  Sn,
  Ur,
  g,
  gn,
  jn,
  k,
  lt,
  qn,
  require_jsx_runtime,
  vn,
  w,
  wt,
  zt
} from "./chunk-CIEVK6OE.js";
import {
  AnimatedObject,
  FluidValue,
  addFluidObserver,
  callFluidObservers,
  colors2,
  createHost,
  createStringInterpolator2,
  each,
  eachProp,
  getFluidValue,
  globals_exports,
  hasFluidValue,
  is,
  removeFluidObserver,
  toArray,
  useSpring
} from "./chunk-UROOLUEL.js";
import {
  area_default,
  line_default
} from "./chunk-JMENM4FH.js";
import {
  require_toString
} from "./chunk-B7PIYN4Z.js";
import "./chunk-V2CXUUTH.js";
import {
  require_react_dom
} from "./chunk-2J4CPGJC.js";
import "./chunk-SEBMSOEZ.js";
import {
  require_react
} from "./chunk-3HGGCXHU.js";
import {
  __commonJS,
  __objRest,
  __toModule
} from "./chunk-AXQKKFRM.js";

// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/lodash/uniqueId.js"(exports, module) {
    var toString = require_toString();
    var idCounter = 0;
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }
    module.exports = uniqueId;
  }
});

// node_modules/@nivo/line/dist/nivo-line.es.js
var import_react = __toModule(require_react());
var import_uniqueId = __toModule(require_uniqueId());
var import_jsx_runtime = __toModule(require_jsx_runtime());

// node_modules/@nivo/line/node_modules/@react-spring/web/dist/react-spring_web.legacy-esm.js
var import_react_dom = __toModule(require_react_dom());
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const _a = props, {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox
  } = _a, attributes = __objRest(_a, [
    "className",
    "style",
    "children",
    "scrollTop",
    "scrollLeft",
    "viewBox"
  ]);
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase())));
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i2) => {
    instance.setAttribute(name, values[i2]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor(_a) {
    var _b = _a, { x, y, z: z4 } = _b, style = __objRest(_b, ["x", "y", "z"]);
    const inputs = [];
    const transforms = [];
    if (x || y || z4) {
      inputs.push([x || 0, y || 0, z4 || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(key === "rotate3d" ? ([x2, y2, z22, deg]) => [
          `rotate3d(${x2},${y2},${z22},${addUnit(deg, unit)})`,
          isValueIdentity(deg, 0)
        ] : (input) => [
          `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
          isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
        ]);
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i2) => {
      const arg1 = getFluidValue(input[0]);
      const [t2, id] = this.transforms[i2](is.arr(arg1) ? arg1 : input.map(getFluidValue));
      transform += " " + t2;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  observerAdded(count) {
    if (count == 1)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
  }
  observerRemoved(count) {
    if (count == 0)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  getComponentProps: (_a) => {
    var _b = _a, { scrollTop, scrollLeft } = _b, props = __objRest(_b, ["scrollTop", "scrollLeft"]);
    return props;
  }
});
var animated = host.animated;

// node_modules/@nivo/line/dist/nivo-line.es.js
function Q() {
  return Q = Object.assign ? Object.assign.bind() : function(e2) {
    for (var o2 = 1; o2 < arguments.length; o2++) {
      var i2 = arguments[o2];
      for (var t2 in i2)
        Object.prototype.hasOwnProperty.call(i2, t2) && (e2[t2] = i2[t2]);
    }
    return e2;
  }, Q.apply(this, arguments);
}
var U = (0, import_react.memo)(function(e2) {
  var o2 = e2.point;
  return (0, import_jsx_runtime.jsx)(w, { id: (0, import_jsx_runtime.jsxs)("span", { children: ["x: ", (0, import_jsx_runtime.jsx)("strong", { children: o2.data.xFormatted }), ", y:", " ", (0, import_jsx_runtime.jsx)("strong", { children: o2.data.yFormatted })] }), enableChip: true, color: o2.serieColor });
});
var Z = (0, import_react.memo)(function(e2) {
  var o2 = e2.slice, i2 = e2.axis, t2 = zt(), n2 = i2 === "x" ? "y" : "x";
  return (0, import_jsx_runtime.jsx)(C, { rows: o2.points.map(function(e3) {
    return [(0, import_jsx_runtime.jsx)(g, { color: e3.serieColor, style: t2.tooltip.chip }, "chip"), e3.serieId, (0, import_jsx_runtime.jsx)("span", { style: t2.tooltip.tableCellValue, children: e3.data[n2 + "Formatted"] }, "value")];
  }) });
});
var $ = { curve: "linear", xScale: { type: "point" }, yScale: { type: "linear", min: 0, max: "auto" }, layers: ["grid", "markers", "axes", "areas", "crosshair", "lines", "points", "slices", "mesh", "legends"], axisBottom: {}, axisLeft: {}, enableGridX: true, enableGridY: true, enablePoints: true, pointSize: 6, pointColor: { from: "color" }, pointBorderWidth: 0, pointBorderColor: { theme: "background" }, enablePointLabel: false, pointLabel: "yFormatted", colors: { scheme: "nivo" }, enableArea: false, areaBaselineValue: 0, areaOpacity: 0.2, areaBlendMode: "normal", lineWidth: 2, legends: [], isInteractive: true, tooltip: U, enableSlices: false, debugSlices: false, sliceTooltip: Z, debugMesh: false, enableCrosshair: true, crosshairType: "bottom-left" };
var _ = Q({}, $, { enablePointLabel: false, useMesh: false, enableTouchCrosshair: false, animate: true, motionConfig: "gentle", defs: [], fill: [], role: "img", initialHiddenIds: [] });
var ee = Q({}, $, { pixelRatio: typeof window != "undefined" && window.devicePixelRatio || 1 });
var oe = function(e2) {
  var i2 = e2.curve;
  return (0, import_react.useMemo)(function() {
    return line_default().defined(function(e3) {
      return e3.x !== null && e3.y !== null;
    }).x(function(e3) {
      return e3.x;
    }).y(function(e3) {
      return e3.y;
    }).curve(lt(i2));
  }, [i2]);
};
var ie = function(e2) {
  var i2 = e2.curve, t2 = e2.yScale, n2 = e2.areaBaselineValue;
  return (0, import_react.useMemo)(function() {
    return area_default().defined(function(e3) {
      return e3.x !== null && e3.y !== null;
    }).x(function(e3) {
      return e3.x;
    }).y1(function(e3) {
      return e3.y;
    }).curve(lt(i2)).y0(t2(n2));
  }, [i2, t2, n2]);
};
var te = function(e2) {
  var i2 = e2.componentId, t2 = e2.enableSlices, n2 = e2.points, r2 = e2.width, a2 = e2.height;
  return (0, import_react.useMemo)(function() {
    if (t2 === false)
      return [];
    if (t2 === "x") {
      var e3 = new Map();
      return n2.forEach(function(o3) {
        o3.data.x !== null && o3.data.y !== null && (e3.has(o3.x) ? e3.get(o3.x).push(o3) : e3.set(o3.x, [o3]));
      }), Array.from(e3.entries()).sort(function(e4, o3) {
        return e4[0] - o3[0];
      }).map(function(e4, o3, t3) {
        var n3, l2, s2 = e4[0], d = e4[1], c = t3[o3 - 1], u = t3[o3 + 1];
        return n3 = c ? s2 - (s2 - c[0]) / 2 : s2, l2 = u ? s2 - n3 + (u[0] - s2) / 2 : r2 - n3, { id: "slice:" + i2 + ":" + s2, x0: n3, x: s2, y0: 0, y: 0, width: l2, height: a2, points: d.reverse() };
      });
    }
    if (t2 === "y") {
      var o2 = new Map();
      return n2.forEach(function(e4) {
        e4.data.x !== null && e4.data.y !== null && (o2.has(e4.y) ? o2.get(e4.y).push(e4) : o2.set(e4.y, [e4]));
      }), Array.from(o2.entries()).sort(function(e4, o3) {
        return e4[0] - o3[0];
      }).map(function(e4, o3, i3) {
        var t3, n3, l2 = e4[0], s2 = e4[1], d = i3[o3 - 1], c = i3[o3 + 1];
        return t3 = d ? l2 - (l2 - d[0]) / 2 : l2, n3 = c ? l2 - t3 + (c[0] - l2) / 2 : a2 - t3, { id: l2, x0: 0, x: 0, y0: t3, y: l2, width: r2, height: n3, points: s2.reverse() };
      });
    }
  }, [i2, t2, a2, n2, r2]);
};
var ne = "line";
var re = function(e2) {
  var n2 = e2.data, r2 = e2.xScale, a2 = r2 === void 0 ? _.xScale : r2, l2 = e2.xFormat, s2 = e2.yScale, c = s2 === void 0 ? _.yScale : s2, h = e2.yFormat, f = e2.width, v = e2.height, p = e2.colors, m = p === void 0 ? _.colors : p, g2 = e2.curve, y = g2 === void 0 ? _.curve : g2, x = e2.areaBaselineValue, b = x === void 0 ? _.areaBaselineValue : x, S = e2.pointColor, M = S === void 0 ? _.pointColor : S, C3 = e2.pointBorderColor, k2 = C3 === void 0 ? _.pointBorderColor : C3, B2 = e2.enableSlices, W2 = B2 === void 0 ? _.enableSlicesTooltip : B2, E = e2.initialHiddenIds, L = E === void 0 ? _.initialHiddenIds : E, G = (0, import_react.useState)((0, import_uniqueId.default)(ne))[0], P2 = Ot(l2), F = Ot(h), O2 = pr(m, "id"), V = zt(), I2 = Xe(M, V), H3 = Xe(k2, V), Y = (0, import_react.useState)(L != null ? L : []), X2 = Y[0], z4 = Y[1], j2 = (0, import_react.useMemo)(function() {
    return dn(n2.filter(function(e3) {
      return X2.indexOf(e3.id) === -1;
    }), a2, c, f, v);
  }, [n2, X2, a2, c, f, v]), D = j2.xScale, q = j2.yScale, J = j2.series, K = (0, import_react.useMemo)(function() {
    var e3 = n2.map(function(e4) {
      return { id: e4.id, label: e4.id, color: O2(e4) };
    }), o2 = e3.map(function(e4) {
      return Q({}, J.find(function(o3) {
        return o3.id === e4.id;
      }), { color: e4.color });
    }).filter(function(e4) {
      return Boolean(e4.id);
    });
    return { legendData: e3.map(function(e4) {
      return Q({}, e4, { hidden: !o2.find(function(o3) {
        return o3.id === e4.id;
      }) });
    }).reverse(), series: o2 };
  }, [n2, J, O2]), N = K.legendData, U2 = K.series, Z2 = (0, import_react.useCallback)(function(e3) {
    z4(function(o2) {
      return o2.indexOf(e3) > -1 ? o2.filter(function(o3) {
        return o3 !== e3;
      }) : [].concat(o2, [e3]);
    });
  }, []), $2 = function(e3) {
    var i2 = e3.series, t2 = e3.getPointColor, n3 = e3.getPointBorderColor, r3 = e3.formatX, a3 = e3.formatY;
    return (0, import_react.useMemo)(function() {
      return i2.reduce(function(e4, o2) {
        return [].concat(e4, o2.data.filter(function(e5) {
          return e5.position.x !== null && e5.position.y !== null;
        }).map(function(i3, l3) {
          var s3 = { id: o2.id + "." + l3, index: e4.length + l3, serieId: o2.id, serieColor: o2.color, x: i3.position.x, y: i3.position.y };
          return s3.color = t2(o2), s3.borderColor = n3(s3), s3.data = Q({}, i3.data, { xFormatted: r3(i3.data.x), yFormatted: a3(i3.data.y) }), s3;
        }));
      }, []);
    }, [i2, t2, n3, r3, a3]);
  }({ series: U2, getPointColor: I2, getPointBorderColor: H3, formatX: P2, formatY: F }), ee2 = te({ componentId: G, enableSlices: W2, points: $2, width: f, height: v });
  return { legendData: N, toggleSerie: Z2, lineGenerator: oe({ curve: y }), areaGenerator: ie({ curve: y, yScale: q, areaBaselineValue: b }), getColor: O2, series: U2, xScale: D, yScale: q, slices: ee2, points: $2 };
};
var ae = function(e2) {
  var o2 = e2.areaBlendMode, i2 = e2.areaOpacity, t2 = e2.color, n2 = e2.fill, r2 = e2.path, a2 = Ur(), l2 = a2.animate, s2 = a2.config, d = Fr(r2), c = useSpring({ color: t2, config: s2, immediate: !l2 });
  return (0, import_jsx_runtime.jsx)(animated.path, { d, fill: n2 || c.color, fillOpacity: i2, strokeWidth: 0, style: { mixBlendMode: o2 } });
};
var le = (0, import_react.memo)(function(e2) {
  var o2 = e2.areaGenerator, i2 = e2.areaOpacity, t2 = e2.areaBlendMode, n2 = e2.lines.slice(0).reverse();
  return (0, import_jsx_runtime.jsx)("g", { children: n2.map(function(e3) {
    return (0, import_jsx_runtime.jsx)(ae, Q({ path: o2(e3.data.map(function(e4) {
      return e4.position;
    })) }, Q({ areaOpacity: i2, areaBlendMode: t2 }, e3)), e3.id);
  }) });
});
var se = (0, import_react.memo)(function(e2) {
  var i2 = e2.lineGenerator, t2 = e2.points, n2 = e2.color, r2 = e2.thickness, a2 = (0, import_react.useMemo)(function() {
    return i2(t2);
  }, [i2, t2]), l2 = Fr(a2);
  return (0, import_jsx_runtime.jsx)(animated.path, { d: l2, fill: "none", strokeWidth: r2, stroke: n2 });
});
var de = (0, import_react.memo)(function(e2) {
  var o2 = e2.lines, i2 = e2.lineGenerator, t2 = e2.lineWidth;
  return o2.slice(0).reverse().map(function(e3) {
    var o3 = e3.id, n2 = e3.data, r2 = e3.color;
    return (0, import_jsx_runtime.jsx)(se, { id: o3, points: n2.map(function(e4) {
      return e4.position;
    }), lineGenerator: i2, color: r2, thickness: t2 }, o3);
  });
});
var ce = (0, import_react.memo)(function(e2) {
  var o2 = e2.slice, i2 = e2.slices, r2 = e2.axis, a2 = e2.debug, l2 = e2.tooltip, s2 = e2.isCurrent, d = e2.setCurrent, c = e2.onMouseEnter, u = e2.onMouseMove, h = e2.onMouseLeave, f = e2.onClick, v = e2.onTouchStart, p = e2.onTouchMove, m = e2.onTouchEnd, g2 = k(), y = g2.showTooltipFromEvent, x = g2.hideTooltip, b = (0, import_react.useCallback)(function(e3) {
    y((0, import_react.createElement)(l2, { slice: o2, axis: r2 }), e3, "right"), d(o2), c && c(o2, e3);
  }, [y, l2, o2, r2, d, c]), S = (0, import_react.useCallback)(function(e3) {
    y((0, import_react.createElement)(l2, { slice: o2, axis: r2 }), e3, "right"), u && u(o2, e3);
  }, [y, l2, o2, r2, u]), M = (0, import_react.useCallback)(function(e3) {
    x(), d(null), h && h(o2, e3);
  }, [x, d, h, o2]), C3 = (0, import_react.useCallback)(function(e3) {
    f && f(o2, e3);
  }, [o2, f]), w2 = (0, import_react.useCallback)(function(e3) {
    y((0, import_react.createElement)(l2, { slice: o2, axis: r2 }), e3, "right"), d(o2), v && v(o2, e3);
  }, [r2, v, d, y, o2, l2]), T = (0, import_react.useCallback)(function(e3) {
    var t2 = e3.touches[0], a3 = document.elementFromPoint(t2.clientX, t2.clientY), s3 = a3 == null ? void 0 : a3.getAttribute("data-ref");
    if (s3) {
      var c2 = i2.find(function(e4) {
        return e4.id === s3;
      });
      c2 && (y((0, import_react.createElement)(l2, { slice: c2, axis: r2 }), e3, "right"), d(c2));
    }
    p && p(o2, e3);
  }, [r2, p, d, y, o2, i2, l2]), k2 = (0, import_react.useCallback)(function(e3) {
    x(), d(null), m && m(o2, e3);
  }, [x, d, m, o2]);
  return (0, import_jsx_runtime.jsx)("rect", { x: o2.x0, y: o2.y0, width: o2.width, height: o2.height, stroke: "red", strokeWidth: a2 ? 1 : 0, strokeOpacity: 0.75, fill: "red", fillOpacity: s2 && a2 ? 0.35 : 0, onMouseEnter: b, onMouseMove: S, onMouseLeave: M, onClick: C3, onTouchStart: w2, onTouchMove: T, onTouchEnd: k2, "data-ref": o2.id });
});
var ue = (0, import_react.memo)(function(e2) {
  var o2 = e2.slices, i2 = e2.axis, t2 = e2.debug, n2 = e2.height, r2 = e2.tooltip, a2 = e2.current, l2 = e2.setCurrent, s2 = e2.onMouseEnter, d = e2.onMouseMove, c = e2.onMouseLeave, u = e2.onClick, h = e2.onTouchStart, f = e2.onTouchMove, v = e2.onTouchEnd;
  return o2.map(function(e3) {
    return (0, import_jsx_runtime.jsx)(ce, { slice: e3, slices: o2, axis: i2, debug: t2, height: n2, tooltip: r2, setCurrent: l2, isCurrent: a2 !== null && a2.id === e3.id, onMouseEnter: s2, onMouseMove: d, onMouseLeave: c, onClick: u, onTouchStart: h, onTouchMove: f, onTouchEnd: v }, e3.id);
  });
});
var he = (0, import_react.memo)(function(e2) {
  var o2 = e2.points, i2 = e2.symbol, t2 = e2.size, n2 = e2.borderWidth, r2 = e2.enableLabel, a2 = e2.label, l2 = e2.labelYOffset, s2 = zt(), c = qn(a2), u = o2.slice(0).reverse().map(function(e3) {
    return { id: e3.id, x: e3.x, y: e3.y, datum: e3.data, fill: e3.color, stroke: e3.borderColor, label: r2 ? c(e3) : null };
  });
  return (0, import_jsx_runtime.jsx)("g", { children: u.map(function(e3) {
    return (0, import_jsx_runtime.jsx)(vn, { x: e3.x, y: e3.y, datum: e3.datum, symbol: i2, size: t2, color: e3.fill, borderWidth: n2, borderColor: e3.stroke, label: e3.label, labelYOffset: l2, theme: s2 }, e3.id);
  }) });
});
var fe = (0, import_react.memo)(function(e2) {
  var o2 = e2.points, i2 = e2.width, r2 = e2.height, a2 = e2.margin, l2 = e2.setCurrent, s2 = e2.onMouseEnter, d = e2.onMouseMove, c = e2.onMouseLeave, u = e2.onClick, h = e2.onTouchStart, f = e2.onTouchMove, v = e2.onTouchEnd, p = e2.tooltip, m = e2.debug, g2 = e2.enableTouchCrosshair, y = k(), x = y.showTooltipAt, b = y.hideTooltip, S = (0, import_react.useCallback)(function(e3, o3) {
    x((0, import_react.createElement)(p, { point: e3 }), [e3.x + a2.left, e3.y + a2.top], "top"), s2 && s2(e3, o3);
  }, [x, p, s2, a2]), M = (0, import_react.useCallback)(function(e3, o3) {
    x((0, import_react.createElement)(p, { point: e3 }), [e3.x + a2.left, e3.y + a2.top], "top"), d && d(e3, o3);
  }, [x, p, a2.left, a2.top, d]), C3 = (0, import_react.useCallback)(function(e3, o3) {
    b(), c && c(e3, o3);
  }, [b, c]), w2 = (0, import_react.useCallback)(function(e3, o3) {
    u && u(e3, o3);
  }, [u]), T = (0, import_react.useCallback)(function(e3, o3) {
    x((0, import_react.createElement)(p, { point: e3 }), [e3.x + a2.left, e3.y + a2.top], "top"), h && h(e3, o3);
  }, [a2.left, a2.top, h, x, p]), k2 = (0, import_react.useCallback)(function(e3, o3) {
    x((0, import_react.createElement)(p, { point: e3 }), [e3.x + a2.left, e3.y + a2.top], "top"), f && f(e3, o3);
  }, [a2.left, a2.top, f, x, p]), B2 = (0, import_react.useCallback)(function(e3, o3) {
    b(), v && v(e3, o3);
  }, [v, b]);
  return (0, import_jsx_runtime.jsx)(I, { nodes: o2, width: i2, height: r2, setCurrent: l2, onMouseEnter: S, onMouseMove: M, onMouseLeave: C3, onClick: w2, onTouchStart: T, onTouchMove: k2, onTouchEnd: B2, enableTouchCrosshair: g2, debug: m });
});
var ve = On(function(e2) {
  var o2 = e2.data, t2 = e2.xScale, n2 = t2 === void 0 ? { type: "point" } : t2, a2 = e2.xFormat, l2 = e2.yScale, s2 = l2 === void 0 ? { type: "linear", min: 0, max: "auto" } : l2, c = e2.yFormat, u = e2.layers, h = u === void 0 ? ["grid", "markers", "axes", "areas", "crosshair", "lines", "points", "slices", "mesh", "legends"] : u, f = e2.curve, v = f === void 0 ? "linear" : f, p = e2.areaBaselineValue, m = p === void 0 ? 0 : p, S = e2.colors, M = S === void 0 ? { scheme: "nivo" } : S, C3 = e2.margin, w2 = e2.width, W2 = e2.height, E = e2.axisTop, G = e2.axisRight, P2 = e2.axisBottom, F = P2 === void 0 ? {} : P2, O2 = e2.axisLeft, V = O2 === void 0 ? {} : O2, H3 = e2.enableGridX, Y = H3 === void 0 || H3, R = e2.enableGridY, A2 = R === void 0 || R, z4 = e2.gridXValues, j2 = e2.gridYValues, D = e2.lineWidth, q = D === void 0 ? 2 : D, J = e2.enableArea, K = J !== void 0 && J, N = e2.areaOpacity, $2 = N === void 0 ? 0.2 : N, _2 = e2.areaBlendMode, ee2 = _2 === void 0 ? "normal" : _2, oe2 = e2.enablePoints, ie2 = oe2 === void 0 || oe2, te2 = e2.pointSymbol, ne2 = e2.pointSize, ae2 = ne2 === void 0 ? 6 : ne2, se2 = e2.pointColor, ce2 = se2 === void 0 ? { from: "color" } : se2, ve2 = e2.pointBorderWidth, pe2 = ve2 === void 0 ? 0 : ve2, me2 = e2.pointBorderColor, ge2 = me2 === void 0 ? { theme: "background" } : me2, ye2 = e2.enablePointLabel, xe = ye2 !== void 0 && ye2, be = e2.pointLabel, Se = be === void 0 ? "data.yFormatted" : be, Me = e2.pointLabelYOffset, Ce = e2.defs, we = Ce === void 0 ? [] : Ce, Te = e2.fill, ke = Te === void 0 ? [] : Te, Be = e2.markers, We = e2.legends, Ee = We === void 0 ? [] : We, Le = e2.isInteractive, Ge = Le === void 0 || Le, Pe = e2.useMesh, Fe = Pe !== void 0 && Pe, Oe = e2.debugMesh, Ve = Oe !== void 0 && Oe, Ie = e2.onMouseEnter, He = e2.onMouseMove, Ye = e2.onMouseLeave, Re = e2.onClick, Ae = e2.onTouchStart, Xe2 = e2.onTouchMove, ze = e2.onTouchEnd, je = e2.tooltip, De = je === void 0 ? U : je, qe = e2.enableSlices, Je = qe !== void 0 && qe, Ke = e2.debugSlices, Ne = Ke !== void 0 && Ke, Qe = e2.sliceTooltip, Ue = Qe === void 0 ? Z : Qe, Ze = e2.enableCrosshair, $e = Ze === void 0 || Ze, _e = e2.crosshairType, eo = _e === void 0 ? "bottom-left" : _e, oo = e2.enableTouchCrosshair, io = oo !== void 0 && oo, to = e2.role, no = to === void 0 ? "img" : to, ro = e2.initialHiddenIds, ao = ro === void 0 ? [] : ro, lo = wt(w2, W2, C3), so = lo.margin, co = lo.innerWidth, uo = lo.innerHeight, ho = lo.outerWidth, fo = lo.outerHeight, vo = re({ data: o2, xScale: n2, xFormat: a2, yScale: s2, yFormat: c, width: co, height: uo, colors: M, curve: v, areaBaselineValue: m, pointColor: ce2, pointBorderColor: ge2, enableSlices: Je, initialHiddenIds: ao }), po = vo.legendData, mo = vo.toggleSerie, go = vo.lineGenerator, yo = vo.areaGenerator, xo = vo.series, bo = vo.xScale, So = vo.yScale, Mo = vo.slices, Co = vo.points, wo = zt(), To = Xe(ce2, wo), ko = Xe(ge2, wo), Bo = (0, import_react.useState)(null), Wo = Bo[0], Eo = Bo[1], Lo = (0, import_react.useState)(null), Go = Lo[0], Po = Lo[1], Fo = { grid: (0, import_jsx_runtime.jsx)(C2, { theme: wo, width: co, height: uo, xScale: Y ? bo : null, yScale: A2 ? So : null, xValues: z4, yValues: j2 }, "grid"), markers: (0, import_jsx_runtime.jsx)(Rn, { markers: Be, width: co, height: uo, xScale: bo, yScale: So, theme: wo }, "markers"), axes: (0, import_jsx_runtime.jsx)(B, { xScale: bo, yScale: So, width: co, height: uo, theme: wo, top: E, right: G, bottom: F, left: V }, "axes"), areas: null, lines: (0, import_jsx_runtime.jsx)(de, { lines: xo, lineGenerator: go, lineWidth: q }, "lines"), slices: null, points: null, crosshair: null, mesh: null, legends: Ee.map(function(e3, o3) {
    return (0, import_jsx_runtime.jsx)(O, Q({}, e3, { containerWidth: co, containerHeight: uo, data: e3.data || po, theme: wo, toggleSerie: e3.toggleSerie ? mo : void 0 }), "legend." + o3);
  }) }, Oo = In(we, xo, ke);
  return K && (Fo.areas = (0, import_jsx_runtime.jsx)(le, { areaGenerator: yo, areaOpacity: $2, areaBlendMode: ee2, lines: xo }, "areas")), Ge && Je !== false && (Fo.slices = (0, import_jsx_runtime.jsx)(ue, { slices: Mo, axis: Je, debug: Ne, height: uo, tooltip: Ue, current: Go, setCurrent: Po, onMouseEnter: Ie, onMouseMove: He, onMouseLeave: Ye, onClick: Re, onTouchStart: Ae, onTouchMove: Xe2, onTouchEnd: ze }, "slices")), ie2 && (Fo.points = (0, import_jsx_runtime.jsx)(he, { points: Co, symbol: te2, size: ae2, color: To, borderWidth: pe2, borderColor: ko, enableLabel: xe, label: Se, labelYOffset: Me }, "points")), Ge && $e && (Wo !== null && (Fo.crosshair = (0, import_jsx_runtime.jsx)(P, { width: co, height: uo, x: Wo.x, y: Wo.y, type: eo }, "crosshair")), Go !== null && (Fo.crosshair = (0, import_jsx_runtime.jsx)(P, { width: co, height: uo, x: Go.x, y: Go.y, type: Je }, "crosshair"))), Ge && Fe && Je === false && (Fo.mesh = (0, import_jsx_runtime.jsx)(fe, { points: Co, width: co, height: uo, margin: so, current: Wo, setCurrent: Eo, onMouseEnter: Ie, onMouseMove: He, onMouseLeave: Ye, onClick: Re, onTouchStart: Ae, onTouchMove: Xe2, onTouchEnd: ze, tooltip: De, enableTouchCrosshair: io, debug: Ve }, "mesh")), (0, import_jsx_runtime.jsx)(gn, { defs: Oo, width: ho, height: fo, margin: so, role: no, children: h.map(function(o3, i2) {
    return typeof o3 == "function" ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: o3(Q({}, e2, { innerWidth: co, innerHeight: uo, series: xo, slices: Mo, points: Co, xScale: bo, yScale: So, lineGenerator: go, areaGenerator: yo, currentPoint: Wo, setCurrentPoint: Eo, currentSlice: Go, setCurrentSlice: Po })) }, i2) : Fo[o3];
  }) });
});
var pe = function(e2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(o2) {
    var i2 = o2.width, t2 = o2.height;
    return (0, import_jsx_runtime.jsx)(ve, Q({ width: i2, height: t2 }, e2));
  } });
};
var me = On(function(e2) {
  var o2 = (0, import_react.useRef)(null), r2 = e2.width, a2 = e2.height, c = e2.margin, u = e2.pixelRatio, h = u === void 0 ? typeof window != "undefined" && window.devicePixelRatio || 1 : u, f = e2.data, v = e2.xScale, p = v === void 0 ? { type: "point" } : v, m = e2.xFormat, y = e2.yScale, x = y === void 0 ? { type: "linear", min: 0, max: "auto" } : y, b = e2.yFormat, S = e2.curve, w2 = S === void 0 ? "linear" : S, T = e2.layers, k2 = T === void 0 ? ["grid", "markers", "axes", "areas", "crosshair", "lines", "points", "slices", "mesh", "legends"] : T, B2 = e2.colors, L = B2 === void 0 ? { scheme: "nivo" } : B2, P2 = e2.lineWidth, F = P2 === void 0 ? 2 : P2, O2 = e2.enableArea, I2 = O2 !== void 0 && O2, H3 = e2.areaBaselineValue, Y = H3 === void 0 ? 0 : H3, R = e2.areaOpacity, A2 = R === void 0 ? 0.2 : R, z4 = e2.enablePoints, j2 = z4 === void 0 || z4, D = e2.pointSize, q = D === void 0 ? 6 : D, Z2 = e2.pointColor, $2 = Z2 === void 0 ? { from: "color" } : Z2, _2 = e2.pointBorderWidth, ee2 = _2 === void 0 ? 0 : _2, oe2 = e2.pointBorderColor, ie2 = oe2 === void 0 ? { theme: "background" } : oe2, te2 = e2.enableGridX, ne2 = te2 === void 0 || te2, ae2 = e2.gridXValues, le2 = e2.enableGridY, se2 = le2 === void 0 || le2, de2 = e2.gridYValues, ce2 = e2.axisTop, ue2 = e2.axisRight, he2 = e2.axisBottom, fe2 = he2 === void 0 ? {} : he2, ve2 = e2.axisLeft, pe2 = ve2 === void 0 ? {} : ve2, me2 = e2.legends, ge2 = me2 === void 0 ? [] : me2, ye2 = e2.isInteractive, xe = ye2 === void 0 || ye2, be = e2.debugMesh, Se = be !== void 0 && be, Me = e2.onMouseLeave, Ce = e2.onClick, we = e2.tooltip, Te = we === void 0 ? U : we, ke = e2.canvasRef, Be = wt(r2, a2, c), We = Be.margin, Ee = Be.innerWidth, Le = Be.innerHeight, Ge = Be.outerWidth, Pe = Be.outerHeight, Fe = zt(), Oe = (0, import_react.useState)(null), Ve = Oe[0], Ie = Oe[1], He = re({ data: f, xScale: p, xFormat: m, yScale: x, yFormat: b, width: Ee, height: Le, colors: L, curve: w2, areaBaselineValue: Y, pointColor: $2, pointBorderColor: ie2 }), Ye = He.lineGenerator, Re = He.areaGenerator, Ae = He.series, Xe2 = He.xScale, ze = He.yScale, je = He.points, De = W({ points: je, width: Ee, height: Le, debug: Se }), qe = De.delaunay, Je = De.voronoi;
  (0, import_react.useEffect)(function() {
    ke && (ke.current = o2.current), o2.current.width = Ge * h, o2.current.height = Pe * h;
    var e3 = o2.current.getContext("2d");
    e3.scale(h, h), e3.fillStyle = Fe.background, e3.fillRect(0, 0, Ge, Pe), e3.translate(We.left, We.top), k2.forEach(function(o3) {
      if (typeof o3 == "function" && o3({ ctx: e3, innerWidth: Ee, innerHeight: Le, series: Ae, points: je, xScale: Xe2, yScale: ze, lineWidth: F, lineGenerator: Ye, areaGenerator: Re, currentPoint: Ve, setCurrentPoint: Ie }), o3 === "grid" && Fe.grid.line.strokeWidth > 0 && (e3.lineWidth = Fe.grid.line.strokeWidth, e3.strokeStyle = Fe.grid.line.stroke, ne2 && z(e3, { width: Ee, height: Le, scale: Xe2, axis: "x", values: ae2 }), se2 && z(e3, { width: Ee, height: Le, scale: ze, axis: "y", values: de2 })), o3 === "axes" && j(e3, { xScale: Xe2, yScale: ze, width: Ee, height: Le, top: ce2, right: ue2, bottom: fe2, left: pe2, theme: Fe }), o3 === "areas" && I2 === true) {
        e3.save(), e3.globalAlpha = A2, Re.context(e3);
        for (var i2 = Ae.length - 1; i2 >= 0; i2--)
          e3.fillStyle = Ae[i2].color, e3.beginPath(), Re(Ae[i2].data.map(function(e4) {
            return e4.position;
          })), e3.fill();
        e3.restore();
      }
      if (o3 === "lines" && (Ye.context(e3), Ae.forEach(function(o4) {
        e3.strokeStyle = o4.color, e3.lineWidth = F, e3.beginPath(), Ye(o4.data.map(function(e4) {
          return e4.position;
        })), e3.stroke();
      })), o3 === "points" && j2 === true && q > 0 && je.forEach(function(o4) {
        e3.fillStyle = o4.color, e3.beginPath(), e3.arc(o4.x, o4.y, q / 2, 0, 2 * Math.PI), e3.fill(), ee2 > 0 && (e3.strokeStyle = o4.borderColor, e3.lineWidth = ee2, e3.stroke());
      }), o3 === "mesh" && Se === true && (z2(e3, Je), Ve && H2(e3, Je, Ve.index)), o3 === "legends") {
        var t2 = Ae.map(function(e4) {
          return { id: e4.id, label: e4.id, color: e4.color };
        }).reverse();
        ge2.forEach(function(o4) {
          H(e3, Q({}, o4, { data: o4.data || t2, containerWidth: Ee, containerHeight: Le, theme: Fe }));
        });
      }
    });
  }, [o2, Ge, Pe, k2, Fe, Ye, Ae, Xe2, ze, ne2, ae2, se2, de2, ce2, ue2, fe2, pe2, ge2, je, j2, q, Ve]);
  var Ke = (0, import_react.useCallback)(function(e3) {
    var i2 = Sn(o2.current, e3), t2 = i2[0], n2 = i2[1];
    if (!jn(We.left, We.top, Ee, Le, t2, n2))
      return null;
    var r3 = qe.find(t2 - We.left, n2 - We.top);
    return je[r3];
  }, [o2, We, Ee, Le, qe]), Ne = k(), Qe = Ne.showTooltipFromEvent, Ue = Ne.hideTooltip, Ze = (0, import_react.useCallback)(function(e3) {
    var o3 = Ke(e3);
    Ie(o3), o3 ? Qe((0, import_react.createElement)(Te, { point: o3 }), e3) : Ue();
  }, [Ke, Ie, Qe, Ue, Te]), $e = (0, import_react.useCallback)(function(e3) {
    Ue(), Ie(null), Ve && Me && Me(Ve, e3);
  }, [Ue, Ie, Me]), _e = (0, import_react.useCallback)(function(e3) {
    if (Ce) {
      var o3 = Ke(e3);
      o3 && Ce(o3, e3);
    }
  }, [Ke, Ce]);
  return (0, import_jsx_runtime.jsx)("canvas", { ref: o2, width: Ge * h, height: Pe * h, style: { width: Ge, height: Pe, cursor: xe ? "auto" : "normal" }, onMouseEnter: xe ? Ze : void 0, onMouseMove: xe ? Ze : void 0, onMouseLeave: xe ? $e : void 0, onClick: xe ? _e : void 0 });
});
var ge = (0, import_react.forwardRef)(function(e2, o2) {
  return (0, import_jsx_runtime.jsx)(me, Q({}, e2, { canvasRef: o2 }));
});
var ye = (0, import_react.forwardRef)(function(e2, o2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(i2) {
    var t2 = i2.width, n2 = i2.height;
    return (0, import_jsx_runtime.jsx)(ge, Q({ width: t2, height: n2 }, e2, { ref: o2 }));
  } });
});
export {
  ne as LINE_UNIQUE_ID_PREFIX,
  ve as Line,
  ge as LineCanvas,
  ee as LineCanvasDefaultProps,
  _ as LineDefaultProps,
  pe as ResponsiveLine,
  ye as ResponsiveLineCanvas,
  ie as useAreaGenerator,
  re as useLine,
  oe as useLineGenerator,
  te as useSlices
};
//# sourceMappingURL=@nivo_line.js.map
