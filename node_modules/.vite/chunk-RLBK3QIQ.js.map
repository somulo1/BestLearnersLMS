{
  "version": 3,
  "sources": ["../d3-hierarchy/src/hierarchy/count.js", "../d3-hierarchy/src/hierarchy/each.js", "../d3-hierarchy/src/hierarchy/eachBefore.js", "../d3-hierarchy/src/hierarchy/eachAfter.js", "../d3-hierarchy/src/hierarchy/sum.js", "../d3-hierarchy/src/hierarchy/sort.js", "../d3-hierarchy/src/hierarchy/path.js", "../d3-hierarchy/src/hierarchy/ancestors.js", "../d3-hierarchy/src/hierarchy/descendants.js", "../d3-hierarchy/src/hierarchy/leaves.js", "../d3-hierarchy/src/hierarchy/links.js", "../d3-hierarchy/src/hierarchy/index.js", "../d3-hierarchy/src/array.js", "../d3-hierarchy/src/pack/enclose.js", "../d3-hierarchy/src/pack/siblings.js", "../d3-hierarchy/src/accessors.js", "../d3-hierarchy/src/constant.js", "../d3-hierarchy/src/pack/index.js", "../d3-hierarchy/src/treemap/dice.js", "../d3-hierarchy/src/treemap/slice.js", "../d3-hierarchy/src/treemap/squarify.js", "../d3-hierarchy/src/treemap/round.js", "../d3-hierarchy/src/treemap/index.js", "../d3-hierarchy/src/treemap/binary.js", "../d3-hierarchy/src/treemap/sliceDice.js", "../d3-hierarchy/src/tree.js", "../d3-hierarchy/src/treemap/resquarify.js"],
  "sourcesContent": ["function count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nexport default function() {\n  return this.eachAfter(count);\n}\n", "export default function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n}\n", "export default function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n}\n", "export default function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n}\n", "export default function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n}\n", "export default function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n", "export default function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n", "export default function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n", "export default function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n}\n", "export default function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n", "export default function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Don\u2019t include the root\u2019s parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n}\n", "import node_count from \"./count.js\";\nimport node_each from \"./each.js\";\nimport node_eachBefore from \"./eachBefore.js\";\nimport node_eachAfter from \"./eachAfter.js\";\nimport node_sum from \"./sum.js\";\nimport node_sort from \"./sort.js\";\nimport node_path from \"./path.js\";\nimport node_ancestors from \"./ancestors.js\";\nimport node_descendants from \"./descendants.js\";\nimport node_leaves from \"./leaves.js\";\nimport node_links from \"./links.js\";\n\nexport default function hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nexport function computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nexport function Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n", "export var slice = Array.prototype.slice;\n\nexport function shuffle(array) {\n  var m = array.length,\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n", "import {shuffle, slice} from \"../array.js\";\n\nexport default function(circles) {\n  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;\n\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p)) ++i;\n    else e = encloseBasis(B = extendBasis(B, p)), i = 0;\n  }\n\n  return e;\n}\n\nfunction extendBasis(B, p) {\n  var i, j;\n\n  if (enclosesWeakAll(p, B)) return [p];\n\n  // If we get here then B must have at least one element.\n  for (i = 0; i < B.length; ++i) {\n    if (enclosesNot(p, B[i])\n        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n      return [B[i], p];\n    }\n  }\n\n  // If we get here then B must have at least two elements.\n  for (i = 0; i < B.length - 1; ++i) {\n    for (j = i + 1; j < B.length; ++j) {\n      if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n          && enclosesNot(encloseBasis2(B[i], p), B[j])\n          && enclosesNot(encloseBasis2(B[j], p), B[i])\n          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {\n        return [B[i], B[j], p];\n      }\n    }\n  }\n\n  // If we get here then something is very wrong.\n  throw new Error;\n}\n\nfunction enclosesNot(a, b) {\n  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\n\nfunction enclosesWeak(a, b) {\n  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction enclosesWeakAll(a, B) {\n  for (var i = 0; i < B.length; ++i) {\n    if (!enclosesWeak(a, B[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction encloseBasis(B) {\n  switch (B.length) {\n    case 1: return encloseBasis1(B[0]);\n    case 2: return encloseBasis2(B[0], B[1]);\n    case 3: return encloseBasis3(B[0], B[1], B[2]);\n  }\n}\n\nfunction encloseBasis1(a) {\n  return {\n    x: a.x,\n    y: a.y,\n    r: a.r\n  };\n}\n\nfunction encloseBasis2(a, b) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,\n      l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x1 + x2 + x21 / l * r21) / 2,\n    y: (y1 + y2 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\n\nfunction encloseBasis3(a, b, c) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x3 = c.x, y3 = c.y, r3 = c.r,\n      a2 = x1 - x2,\n      a3 = x1 - x3,\n      b2 = y1 - y2,\n      b3 = y1 - y3,\n      c2 = r2 - r1,\n      c3 = r3 - r1,\n      d1 = x1 * x1 + y1 * y1 - r1 * r1,\n      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,\n      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,\n      ab = a3 * b2 - a2 * b3,\n      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,\n      xb = (b3 * c2 - b2 * c3) / ab,\n      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,\n      yb = (a2 * c3 - a3 * c2) / ab,\n      A = xb * xb + yb * yb - 1,\n      B = 2 * (r1 + xa * xb + ya * yb),\n      C = xa * xa + ya * ya - r1 * r1,\n      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n  return {\n    x: x1 + xa + xb * r,\n    y: y1 + ya + yb * r,\n    r: r\n  };\n}\n", "import enclose from \"./enclose.js\";\n\nfunction place(b, a, c) {\n  var dx = b.x - a.x, x, a2,\n      dy = b.y - a.y, y, b2,\n      d2 = dx * dx + dy * dy;\n  if (d2) {\n    a2 = a.r + c.r, a2 *= a2;\n    b2 = b.r + c.r, b2 *= b2;\n    if (a2 > b2) {\n      x = (d2 + b2 - a2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));\n      c.x = b.x - x * dx - y * dy;\n      c.y = b.y - x * dy + y * dx;\n    } else {\n      x = (d2 + a2 - b2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));\n      c.x = a.x + x * dx - y * dy;\n      c.y = a.y + x * dy + y * dx;\n    }\n  } else {\n    c.x = a.x + c.r;\n    c.y = a.y;\n  }\n}\n\nfunction intersects(a, b) {\n  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction score(node) {\n  var a = node._,\n      b = node.next._,\n      ab = a.r + b.r,\n      dx = (a.x * b.r + b.x * a.r) / ab,\n      dy = (a.y * b.r + b.y * a.r) / ab;\n  return dx * dx + dy * dy;\n}\n\nfunction Node(circle) {\n  this._ = circle;\n  this.next = null;\n  this.previous = null;\n}\n\nexport function packEnclose(circles) {\n  if (!(n = circles.length)) return 0;\n\n  var a, b, c, n, aa, ca, i, j, k, sj, sk;\n\n  // Place the first circle.\n  a = circles[0], a.x = 0, a.y = 0;\n  if (!(n > 1)) return a.r;\n\n  // Place the second circle.\n  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n  if (!(n > 2)) return a.r + b.r;\n\n  // Place the third circle.\n  place(b, a, c = circles[2]);\n\n  // Initialize the front-chain using the first three circles a, b and c.\n  a = new Node(a), b = new Node(b), c = new Node(c);\n  a.next = c.previous = b;\n  b.next = a.previous = c;\n  c.next = b.previous = a;\n\n  // Attempt to place each remaining circle\u2026\n  pack: for (i = 3; i < n; ++i) {\n    place(a._, b._, c = circles[i]), c = new Node(c);\n\n    // Find the closest intersecting circle on the front-chain, if any.\n    // \u201CCloseness\u201D is determined by linear distance along the front-chain.\n    // \u201CAhead\u201D or \u201Cbehind\u201D is likewise determined by linear distance.\n    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;\n    do {\n      if (sj <= sk) {\n        if (intersects(j._, c._)) {\n          b = j, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sj += j._.r, j = j.next;\n      } else {\n        if (intersects(k._, c._)) {\n          a = k, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sk += k._.r, k = k.previous;\n      }\n    } while (j !== k.next);\n\n    // Success! Insert the new circle c between a and b.\n    c.previous = a, c.next = b, a.next = b.previous = b = c;\n\n    // Compute the new closest circle pair to the centroid.\n    aa = score(a);\n    while ((c = c.next) !== b) {\n      if ((ca = score(c)) < aa) {\n        a = c, aa = ca;\n      }\n    }\n    b = a.next;\n  }\n\n  // Compute the enclosing circle of the front chain.\n  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);\n\n  // Translate the circles to put the enclosing circle around the origin.\n  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;\n\n  return c.r;\n}\n\nexport default function(circles) {\n  packEnclose(circles);\n  return circles;\n}\n", "export function optional(f) {\n  return f == null ? null : required(f);\n}\n\nexport function required(f) {\n  if (typeof f !== \"function\") throw new Error;\n  return f;\n}\n", "export function constantZero() {\n  return 0;\n}\n\nexport default function(x) {\n  return function() {\n    return x;\n  };\n}\n", "import {packEnclose} from \"./siblings.js\";\nimport {optional} from \"../accessors.js\";\nimport constant, {constantZero} from \"../constant.js\";\n\nfunction defaultRadius(d) {\n  return Math.sqrt(d.value);\n}\n\nexport default function() {\n  var radius = null,\n      dx = 1,\n      dy = 1,\n      padding = constantZero;\n\n  function pack(root) {\n    root.x = dx / 2, root.y = dy / 2;\n    if (radius) {\n      root.eachBefore(radiusLeaf(radius))\n          .eachAfter(packChildren(padding, 0.5))\n          .eachBefore(translateChild(1));\n    } else {\n      root.eachBefore(radiusLeaf(defaultRadius))\n          .eachAfter(packChildren(constantZero, 1))\n          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n    }\n    return root;\n  }\n\n  pack.radius = function(x) {\n    return arguments.length ? (radius = optional(x), pack) : radius;\n  };\n\n  pack.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n  };\n\n  pack.padding = function(x) {\n    return arguments.length ? (padding = typeof x === \"function\" ? x : constant(+x), pack) : padding;\n  };\n\n  return pack;\n}\n\nfunction radiusLeaf(radius) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius(node) || 0);\n    }\n  };\n}\n\nfunction packChildren(padding, k) {\n  return function(node) {\n    if (children = node.children) {\n      var children,\n          i,\n          n = children.length,\n          r = padding(node) * k || 0,\n          e;\n\n      if (r) for (i = 0; i < n; ++i) children[i].r += r;\n      e = packEnclose(children);\n      if (r) for (i = 0; i < n; ++i) children[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\n\nfunction translateChild(k) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k;\n    if (parent) {\n      node.x = parent.x + k * node.x;\n      node.y = parent.y + k * node.y;\n    }\n  };\n}\n", "export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n}\n", "export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n}\n", "import treemapDice from \"./dice.js\";\nimport treemapSlice from \"./slice.js\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n", "export default function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n}\n", "import roundNode from \"./round.js\";\nimport squarify from \"./squarify.js\";\nimport {required} from \"../accessors.js\";\nimport constant, {constantZero} from \"../constant.js\";\n\nexport default function() {\n  var tile = squarify,\n      round = false,\n      dx = 1,\n      dy = 1,\n      paddingStack = [0],\n      paddingInner = constantZero,\n      paddingTop = constantZero,\n      paddingRight = constantZero,\n      paddingBottom = constantZero,\n      paddingLeft = constantZero;\n\n  function treemap(root) {\n    root.x0 =\n    root.y0 = 0;\n    root.x1 = dx;\n    root.y1 = dy;\n    root.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(node) {\n    var p = paddingStack[node.depth],\n        x0 = node.x0 + p,\n        y0 = node.y0 + p,\n        x1 = node.x1 - p,\n        y1 = node.y1 - p;\n    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n    node.x0 = x0;\n    node.y0 = y0;\n    node.x1 = x1;\n    node.y1 = y1;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x0 += paddingLeft(node) - p;\n      y0 += paddingTop(node) - p;\n      x1 -= paddingRight(node) - p;\n      y1 -= paddingBottom(node) - p;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      tile(node, x0, y0, x1, y1);\n    }\n  }\n\n  treemap.round = function(x) {\n    return arguments.length ? (round = !!x, treemap) : round;\n  };\n\n  treemap.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n  };\n\n  treemap.tile = function(x) {\n    return arguments.length ? (tile = required(x), treemap) : tile;\n  };\n\n  treemap.padding = function(x) {\n    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n  };\n\n  treemap.paddingInner = function(x) {\n    return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant(+x), treemap) : paddingInner;\n  };\n\n  treemap.paddingOuter = function(x) {\n    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n  };\n\n  treemap.paddingTop = function(x) {\n    return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant(+x), treemap) : paddingTop;\n  };\n\n  treemap.paddingRight = function(x) {\n    return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant(+x), treemap) : paddingRight;\n  };\n\n  treemap.paddingBottom = function(x) {\n    return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant(+x), treemap) : paddingBottom;\n  };\n\n  treemap.paddingLeft = function(x) {\n    return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant(+x), treemap) : paddingLeft;\n  };\n\n  return treemap;\n}\n", "export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      i, n = nodes.length,\n      sum, sums = new Array(n + 1);\n\n  for (sums[0] = sum = i = 0; i < n; ++i) {\n    sums[i + 1] = sum += nodes[i].value;\n  }\n\n  partition(0, n, parent.value, x0, y0, x1, y1);\n\n  function partition(i, j, value, x0, y0, x1, y1) {\n    if (i >= j - 1) {\n      var node = nodes[i];\n      node.x0 = x0, node.y0 = y0;\n      node.x1 = x1, node.y1 = y1;\n      return;\n    }\n\n    var valueOffset = sums[i],\n        valueTarget = (value / 2) + valueOffset,\n        k = i + 1,\n        hi = j - 1;\n\n    while (k < hi) {\n      var mid = k + hi >>> 1;\n      if (sums[mid] < valueTarget) k = mid + 1;\n      else hi = mid;\n    }\n\n    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;\n\n    var valueLeft = sums[k] - valueOffset,\n        valueRight = value - valueLeft;\n\n    if ((x1 - x0) > (y1 - y0)) {\n      var xk = (x0 * valueRight + x1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, xk, y1);\n      partition(k, j, valueRight, xk, y0, x1, y1);\n    } else {\n      var yk = (y0 * valueRight + y1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, x1, yk);\n      partition(k, j, valueRight, x0, yk, x1, y1);\n    }\n  }\n}\n", "import dice from \"./dice.js\";\nimport slice from \"./slice.js\";\n\nexport default function(parent, x0, y0, x1, y1) {\n  (parent.depth & 1 ? slice : dice)(parent, x0, y0, x1, y1);\n}\n", "import {Node} from \"./hierarchy/index.js\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-\u2019s ancestor is a sibling of v, returns vi-\u2019s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.\u2019s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n", "import treemapDice from \"./dice.js\";\nimport treemapSlice from \"./slice.js\";\nimport {phi, squarifyRatio} from \"./squarify.js\";\n\nexport default (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n"],
  "mappings": "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",
  "names": []
}
