import {
  B,
  C as C2,
  W,
  Y
} from "./chunk-JTYFOI3S.js";
import "./chunk-B545YG5G.js";
import {
  O
} from "./chunk-5CPLXP24.js";
import {
  Xe,
  pr
} from "./chunk-LIF42OKE.js";
import "./chunk-SY6HMO6G.js";
import "./chunk-AD5TROZ4.js";
import "./chunk-6JM3GFV6.js";
import "./chunk-DZU3R4ZD.js";
import {
  C,
  Fr,
  In,
  It,
  Ot,
  St,
  Ur,
  Wn,
  bt,
  ft,
  g,
  gn,
  k,
  require_jsx_runtime,
  st,
  w,
  wt,
  zt
} from "./chunk-CIEVK6OE.js";
import {
  AnimatedObject,
  FluidValue,
  addFluidObserver,
  callFluidObservers,
  colors2,
  createHost,
  createStringInterpolator2,
  each,
  eachProp,
  getFluidValue,
  globals_exports,
  hasFluidValue,
  is,
  removeFluidObserver,
  toArray,
  useSpring
} from "./chunk-UROOLUEL.js";
import {
  area_default,
  stack_default
} from "./chunk-JMENM4FH.js";
import "./chunk-B7PIYN4Z.js";
import "./chunk-V2CXUUTH.js";
import {
  require_react_dom
} from "./chunk-2J4CPGJC.js";
import "./chunk-SEBMSOEZ.js";
import {
  require_react
} from "./chunk-3HGGCXHU.js";
import {
  __objRest,
  __toModule
} from "./chunk-AXQKKFRM.js";

// node_modules/@nivo/stream/dist/nivo-stream.es.js
var import_react = __toModule(require_react());

// node_modules/@nivo/stream/node_modules/@react-spring/web/dist/react-spring_web.legacy-esm.js
var import_react_dom = __toModule(require_react_dom());
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const _a = props, {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox
  } = _a, attributes = __objRest(_a, [
    "className",
    "style",
    "children",
    "scrollTop",
    "scrollLeft",
    "viewBox"
  ]);
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n) => "-" + n.toLowerCase())));
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i2) => {
    instance.setAttribute(name, values[i2]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor(_a) {
    var _b = _a, { x, y, z } = _b, style = __objRest(_b, ["x", "y", "z"]);
    const inputs = [];
    const transforms = [];
    if (x || y || z) {
      inputs.push([x || 0, y || 0, z || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(key === "rotate3d" ? ([x2, y2, z2, deg]) => [
          `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,
          isValueIdentity(deg, 0)
        ] : (input) => [
          `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
          isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
        ]);
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i2) => {
      const arg1 = getFluidValue(input[0]);
      const [t2, id] = this.transforms[i2](is.arr(arg1) ? arg1 : input.map(getFluidValue));
      transform += " " + t2;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  observerAdded(count) {
    if (count == 1)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
  }
  observerRemoved(count) {
    if (count == 0)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  getComponentProps: (_a) => {
    var _b = _a, { scrollTop, scrollLeft } = _b, props = __objRest(_b, ["scrollTop", "scrollLeft"]);
    return props;
  }
});
var animated = host.animated;

// node_modules/@nivo/stream/dist/nivo-stream.es.js
var import_jsx_runtime = __toModule(require_jsx_runtime());
function j() {
  return j = Object.assign ? Object.assign.bind() : function(o2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var r2 = arguments[e2];
      for (var t2 in r2)
        Object.prototype.hasOwnProperty.call(r2, t2) && (o2[t2] = r2[t2]);
    }
    return o2;
  }, j.apply(this, arguments);
}
var E = function(r2) {
  var t2 = r2.layer, i2 = r2.fillOpacity, a = r2.borderWidth, d = r2.getBorderColor, c = r2.isInteractive, s = r2.tooltip, u = k(), f = u.showTooltipFromEvent, h = u.hideTooltip, p = (0, import_react.useCallback)(function(o2) {
    f((0, import_react.createElement)(s, { layer: t2 }), o2, "left");
  }, [f, t2]), v = Ur(), m = v.animate, y = v.config, g2 = Fr(t2.path), b = useSpring({ color: t2.color, config: y, immediate: !m });
  return (0, import_jsx_runtime.jsx)(animated.path, { d: g2, fill: t2.fill ? t2.fill : b.color, fillOpacity: i2, stroke: d(t2), strokeWidth: a, onMouseMove: c ? p : void 0, onMouseEnter: c ? p : void 0, onMouseLeave: c ? h : void 0 });
};
var P = function(o2) {
  var e2 = o2.layers, r2 = o2.fillOpacity, t2 = o2.borderWidth, i2 = o2.getBorderColor, n = o2.isInteractive, l = o2.tooltip;
  return (0, import_jsx_runtime.jsx)("g", { children: e2.map(function(o3, e3) {
    return (0, import_jsx_runtime.jsx)(E, { layer: o3, getBorderColor: i2, borderWidth: t2, fillOpacity: r2, isInteractive: n, tooltip: l }, e3);
  }) });
};
var H = function(o2, e2) {
  var r2 = o2.y2;
  return e2 === "center" ? r2 = o2.y1 + (o2.y2 - o2.y1) / 2 : e2 === "start" && (r2 = o2.y1), r2;
};
var X = function(o2) {
  var r2 = o2.data, t2 = o2.dotComponent, i2 = o2.position, n = o2.getSize, l = o2.getColor, a = o2.getBorderWidth, d = o2.getBorderColor;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: r2.map(function(o3, r3) {
    return (0, import_react.createElement)(t2, { key: r3, datum: o3, x: o3.x, y: H(o3, i2), size: n(o3), color: l(o3), borderWidth: a(o3), borderColor: d(o3) });
  }) });
};
var Y2 = function(t2) {
  var i2 = t2.slice, n = t2.height, l = t2.tooltip, a = (0, import_react.useState)(false), d = a[0], c = a[1], s = k(), u = s.showTooltipFromEvent, f = s.hideTooltip, h = (0, import_react.useCallback)(function(o2) {
    c(true), u((0, import_react.createElement)(l, { slice: i2 }), o2, "left");
  }, [c, u, l, i2]), p = (0, import_react.useCallback)(function() {
    c(false), f();
  }, [c, f]);
  return (0, import_jsx_runtime.jsxs)("g", { transform: "translate(" + i2.x + ", 0)", children: [d && (0, import_jsx_runtime.jsx)("line", { x1: 0, x2: 0, y1: 0, y2: n, stroke: "#000", strokeOpacity: 0.35, strokeWidth: 1 }), (0, import_jsx_runtime.jsx)("rect", { x: -20, width: 40, height: n, fill: "#000", fillOpacity: 0, onMouseEnter: h, onMouseMove: h, onMouseLeave: p })] });
};
var A = function(o2) {
  var e2 = o2.slices, r2 = o2.height, t2 = o2.tooltip;
  return (0, import_jsx_runtime.jsx)("g", { children: e2.map(function(o3) {
    return (0, import_jsx_runtime.jsx)(Y2, { slice: o3, height: r2, tooltip: t2 }, o3.index);
  }) });
};
var R = { label: "id", order: "none", offsetType: "wiggle", curve: "catmullRom", axisBottom: {}, axisLeft: {}, enableGridX: false, enableGridY: true, colors: { scheme: "nivo" }, fillOpacity: 1, borderWidth: 0, borderColor: { from: "color", modifiers: [["darker", 1]] }, enableDots: false, dotPosition: "center", dotComponent: function(o2) {
  var e2 = o2.x, r2 = o2.y, t2 = o2.size, i2 = o2.color, l = o2.borderWidth, a = o2.borderColor, d = Ur(), c = d.animate, s = d.config, u = useSpring({ x: e2, y: r2, radius: 0.5 * t2, color: i2, config: s, immediate: !c });
  return (0, import_jsx_runtime.jsx)(animated.circle, { cx: u.x, cy: u.y, r: u.radius, fill: u.color, strokeWidth: l, stroke: a });
}, dotSize: 6, dotColor: { from: "color" }, dotBorderWidth: 0, dotBorderColor: { from: "color" }, isInteractive: true, tooltip: function(o2) {
  var e2 = o2.layer;
  return (0, import_jsx_runtime.jsx)(w, { id: e2.label, enableChip: true, color: e2.color });
}, enableStackTooltip: true, stackTooltip: function(o2) {
  var e2 = o2.slice, r2 = (0, import_react.useMemo)(function() {
    return e2.stack.map(function(o3) {
      return [(0, import_jsx_runtime.jsx)(g, { color: o3.color }, o3.layerId), o3.layerLabel, o3.formattedValue];
    });
  }, [e2]);
  return (0, import_jsx_runtime.jsx)(C, { rows: r2 });
}, legends: [], legendLabel: "id", role: "application" };
var V = j({}, R, { layers: ["grid", "axes", "layers", "dots", "slices", "legends"], defs: [], fill: [], animate: true, motionConfig: "default", role: "img", isFocusable: false });
var q = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var J = function(o2) {
  var r2 = o2.data, n = o2.keys, l = o2.label, h = o2.valueFormat, y = o2.offsetType, C3 = o2.order, B2 = o2.curve, W2 = o2.layers, k2 = W2 === void 0 ? V.layers : W2, S = o2.width, O2 = o2.height, w3 = o2.margin, I2 = o2.axisTop, E2 = o2.axisRight, H2 = o2.axisBottom, Y3 = H2 === void 0 ? V.axisBottom : H2, q2 = o2.axisLeft, J2 = q2 === void 0 ? V.axisLeft : q2, K2 = o2.enableGridX, N2 = K2 === void 0 ? V.enableGridX : K2, Q = o2.enableGridY, U = Q === void 0 ? V.enableGridY : Q, Z = o2.colors, $ = o2.fillOpacity, _ = $ === void 0 ? V.fillOpacity : $, oo = o2.borderWidth, eo = oo === void 0 ? V.borderWidth : oo, ro = o2.borderColor, to = o2.defs, io = to === void 0 ? V.defs : to, no = o2.fill, lo = no === void 0 ? V.fill : no, ao = o2.enableDots, co = ao === void 0 ? V.enableDots : ao, so = o2.dotPosition, uo = so === void 0 ? V.dotPosition : so, fo = o2.dotComponent, ho = fo === void 0 ? V.dotComponent : fo, po = o2.dotSize, vo = o2.dotColor, mo = o2.dotBorderWidth, yo = o2.dotBorderColor, go = o2.isInteractive, bo = go === void 0 ? V.isInteractive : go, xo = o2.tooltip, Co = xo === void 0 ? V.tooltip : xo, Bo = o2.enableStackTooltip, Wo = Bo === void 0 ? V.enableStackTooltip : Bo, ko = o2.stackTooltip, So = ko === void 0 ? V.stackTooltip : ko, Oo = o2.legends, To = Oo === void 0 ? V.legends : Oo, wo = o2.role, Io = o2.ariaLabel, Do = o2.ariaLabelledBy, Lo = o2.ariaDescribedBy, Mo = wt(S, O2, w3), zo = Mo.margin, Fo = Mo.innerWidth, Go = Mo.innerHeight, jo = Mo.outerWidth, Eo = Mo.outerHeight, Po = function(o3) {
    var e2 = o3.width, r3 = o3.height, i2 = o3.data, n2 = o3.keys, l2 = o3.label, h2 = l2 === void 0 ? R.label : l2, p = o3.valueFormat, v = o3.offsetType, m = v === void 0 ? R.offsetType : v, y2 = o3.order, g2 = y2 === void 0 ? R.order : y2, b = o3.curve, x = b === void 0 ? R.curve : b, C4 = o3.colors, B3 = C4 === void 0 ? R.colors : C4, W3 = o3.borderColor, k3 = W3 === void 0 ? R.borderColor : W3, S2 = o3.dotSize, O3 = S2 === void 0 ? R.dotSize : S2, T2 = o3.dotColor, w4 = T2 === void 0 ? R.dotColor : T2, I3 = o3.dotBorderWidth, E3 = I3 === void 0 ? R.dotBorderWidth : I3, P2 = o3.dotBorderColor, H3 = P2 === void 0 ? R.dotBorderColor : P2, X2 = bt(x), Y4 = (0, import_react.useMemo)(function() {
      return area_default().x(function(o4) {
        return o4.x;
      }).y0(function(o4) {
        return o4.y1;
      }).y1(function(o4) {
        return o4.y2;
      }).curve(X2);
    }, [X2]), A2 = (0, import_react.useMemo)(function() {
      return stack_default().keys(n2).offset(ft(m)).order(st(g2));
    }, [n2, m, g2]), V2 = (0, import_react.useMemo)(function() {
      var o4 = [], t2 = [], n3 = A2(i2).map(function(e3) {
        return e3.map(function(r4) {
          return o4.push(r4[0]), t2.push(r4[1]), j({}, r4, { value: r4.data[e3.key] });
        });
      }), l3 = Math.min.apply(Math, o4), a = Math.max.apply(Math, t2);
      return [n3, Y({ type: "point" }, { all: Array.from({ length: i2.length }, function(o5, e3) {
        return e3;
      }), min: 0, max: i2.length }, e2), W({ type: "linear", min: l3 }, { all: [l3, a], min: l3, max: a }, r3, "y")];
    }, [A2, i2, e2, r3]), q3 = V2[0], J3 = V2[1], K3 = V2[2], N3 = zt(), Q2 = pr(B3, "id"), U2 = Xe(k3, N3), Z2 = (0, import_react.useMemo)(function() {
      return typeof O3 == "function" ? O3 : function() {
        return O3;
      };
    }, [O3]), $2 = Xe(w4, N3), _2 = (0, import_react.useMemo)(function() {
      return typeof E3 == "function" ? E3 : function() {
        return E3;
      };
    }, [E3]), oo2 = Xe(H3, N3), eo2 = Wn(h2), ro2 = Ot(p), to2 = (0, import_react.useMemo)(function() {
      return q3.map(function(o4, e3) {
        var r4 = o4.map(function(o5, r5) {
          return { layerId: n2[e3], layerLabel: "", index: r5, color: "", x: J3(r5), value: o5.value, formattedValue: ro2(o5.value), y1: K3(o5[0]), y2: K3(o5[1]) };
        }), t2 = { id: n2[e3], path: Y4(r4) }, i3 = j({}, t2, { label: eo2(t2), color: Q2(t2) });
        return j({}, i3, { data: r4.map(function(o5) {
          return o5.layerLabel = i3.label, o5.color = i3.color, o5;
        }) });
      });
    }, [q3, n2, eo2, Y4, Q2, J3, K3, ro2]), io2 = (0, import_react.useMemo)(function() {
      return Array.from({ length: i2.length }, function(o4, e3) {
        var r4 = to2.map(function(o5) {
          return o5.data[e3];
        }).sort(function(o5, e4) {
          return o5.y2 - e4.y2;
        });
        return { index: e3, x: to2[0].data[e3].x, stack: r4 };
      });
    }, [i2.length, to2]), no2 = (0, import_react.useMemo)(function() {
      return { xScale: J3, yScale: K3, layers: to2, slices: io2 };
    }, [J3, K3, to2, io2]);
    return { xScale: J3, yScale: K3, layers: to2, slices: io2, getBorderColor: U2, getDotSize: Z2, getDotColor: $2, getDotBorderWidth: _2, getDotBorderColor: oo2, layerContext: no2 };
  }({ width: Fo, height: Go, data: r2, keys: n, label: l, valueFormat: h, offsetType: y, order: C3, curve: B2, colors: Z, borderColor: ro, dotSize: po, dotColor: vo, dotBorderWidth: mo, dotBorderColor: yo }), Ho = Po.xScale, Xo = Po.yScale, Yo = Po.layers, Ao = Po.slices, Ro = Po.getBorderColor, Vo = Po.getDotSize, qo = Po.getDotColor, Jo = Po.getDotBorderWidth, Ko = Po.getDotBorderColor, No = Po.layerContext, Qo = In(io, Yo, lo), Uo = { grid: null, axes: null, layers: null, dots: null, slices: null, legends: null };
  return k2.includes("grid") && (Uo.grid = (0, import_jsx_runtime.jsx)(C2, { width: Fo, height: Go, xScale: N2 ? Ho : null, yScale: U ? Xo : null }, "grid")), k2.includes("axes") && (Uo.axes = (0, import_jsx_runtime.jsx)(B, { xScale: Ho, yScale: Xo, width: Fo, height: Go, top: I2, right: E2, bottom: Y3, left: J2 }, "axes")), k2.includes("layers") && (Uo.layers = (0, import_jsx_runtime.jsx)(P, { layers: Yo, fillOpacity: _, borderWidth: eo, getBorderColor: Ro, isInteractive: bo, tooltip: Co }, "layers")), k2.includes("dots") && co && (Uo.dots = (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: Yo.map(function(o3) {
    return (0, import_jsx_runtime.jsx)(X, { id: o3.id, color: o3.color, data: o3.data, dotComponent: ho, position: uo, getSize: Vo, getColor: qo, getBorderWidth: Jo, getBorderColor: Ko }, o3.id);
  }) }, "dots")), k2.includes("slices") && bo && Wo && (Uo.slices = (0, import_jsx_runtime.jsx)(A, { slices: Ao, height: Go, tooltip: So }, "slices")), k2.includes("legends") && (Uo.legends = (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: To.map(function(o3, e2) {
    var r3 = Yo.map(function(o4) {
      return { id: o4.id, label: o4.label, color: o4.color, fill: o4.fill };
    }).reverse();
    return (0, import_jsx_runtime.jsx)(O, j({}, o3, { containerWidth: Fo, containerHeight: Go, data: r3 }), e2);
  }) }, "legends")), (0, import_jsx_runtime.jsx)(gn, { width: jo, height: Eo, margin: zo, defs: Qo, role: wo, ariaLabel: Io, ariaLabelledBy: Do, ariaDescribedBy: Lo, children: k2.map(function(o3, r3) {
    var t2;
    return typeof o3 == "function" ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: (0, import_react.createElement)(o3, No) }, r3) : (t2 = Uo == null ? void 0 : Uo[o3]) != null ? t2 : null;
  }) });
};
var K = function(o2) {
  var e2 = o2.isInteractive, r2 = e2 === void 0 ? V.isInteractive : e2, t2 = o2.animate, i2 = t2 === void 0 ? V.animate : t2, n = o2.motionConfig, l = n === void 0 ? V.motionConfig : n, a = o2.theme, d = o2.renderWrapper, c = function(o3, e3) {
    if (o3 == null)
      return {};
    var r3, t3, i3 = {}, n2 = Object.keys(o3);
    for (t3 = 0; t3 < n2.length; t3++)
      r3 = n2[t3], e3.indexOf(r3) >= 0 || (i3[r3] = o3[r3]);
    return i3;
  }(o2, q);
  return (0, import_jsx_runtime.jsx)(St, { animate: i2, isInteractive: r2, motionConfig: l, renderWrapper: d, theme: a, children: (0, import_jsx_runtime.jsx)(J, j({ isInteractive: r2 }, c)) });
};
var N = function(o2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(e2) {
    var r2 = e2.width, t2 = e2.height;
    return (0, import_jsx_runtime.jsx)(K, j({ width: r2, height: t2 }, o2));
  } });
};
export {
  N as ResponsiveStream,
  K as Stream,
  R as defaultProps,
  V as svgDefaultProps
};
//# sourceMappingURL=@nivo_stream.js.map
