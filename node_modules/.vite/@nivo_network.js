import {
  J,
  R,
  S,
  j
} from "./chunk-P6YTOCWM.js";
import {
  Xe
} from "./chunk-LIF42OKE.js";
import "./chunk-6YWBRFZ4.js";
import "./chunk-DZU3R4ZD.js";
import "./chunk-3T4KNB5M.js";
import "./chunk-NIFAYVBJ.js";
import {
  It,
  Mn,
  Sn,
  St,
  Ur,
  gn,
  k,
  require_jsx_runtime,
  w,
  wt,
  zt
} from "./chunk-CIEVK6OE.js";
import {
  AnimatedObject,
  FluidValue,
  addFluidObserver,
  callFluidObservers,
  colors2,
  createHost,
  createStringInterpolator2,
  each,
  eachProp,
  getFluidValue,
  globals_exports,
  hasFluidValue,
  is,
  removeFluidObserver,
  to,
  toArray,
  useTransition
} from "./chunk-UROOLUEL.js";
import "./chunk-JMENM4FH.js";
import "./chunk-B7PIYN4Z.js";
import "./chunk-V2CXUUTH.js";
import {
  require_react_dom
} from "./chunk-2J4CPGJC.js";
import "./chunk-SEBMSOEZ.js";
import {
  require_react
} from "./chunk-3HGGCXHU.js";
import {
  __objRest,
  __toModule
} from "./chunk-AXQKKFRM.js";

// node_modules/@nivo/network/dist/nivo-network.es.js
var import_react = __toModule(require_react());

// node_modules/@nivo/network/node_modules/@react-spring/web/dist/react-spring_web.legacy-esm.js
var import_react_dom = __toModule(require_react_dom());
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const _a = props, {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox
  } = _a, attributes = __objRest(_a, [
    "className",
    "style",
    "children",
    "scrollTop",
    "scrollLeft",
    "viewBox"
  ]);
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase())));
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i2) => {
    instance.setAttribute(name, values[i2]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor(_a) {
    var _b = _a, { x: x2, y: y2, z } = _b, style = __objRest(_b, ["x", "y", "z"]);
    const inputs = [];
    const transforms = [];
    if (x2 || y2 || z) {
      inputs.push([x2 || 0, y2 || 0, z || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(key === "rotate3d" ? ([x22, y22, z2, deg]) => [
          `rotate3d(${x22},${y22},${z2},${addUnit(deg, unit)})`,
          isValueIdentity(deg, 0)
        ] : (input) => [
          `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
          isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
        ]);
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i2) => {
      const arg1 = getFluidValue(input[0]);
      const [t2, id] = this.transforms[i2](is.arr(arg1) ? arg1 : input.map(getFluidValue));
      transform += " " + t2;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  observerAdded(count) {
    if (count == 1)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
  }
  observerRemoved(count) {
    if (count == 0)
      each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  getComponentProps: (_a) => {
    var _b = _a, { scrollTop, scrollLeft } = _b, props = __objRest(_b, ["scrollTop", "scrollLeft"]);
    return props;
  }
});
var animated = host.animated;

// node_modules/@nivo/network/dist/nivo-network.es.js
var import_jsx_runtime = __toModule(require_jsx_runtime());

// node_modules/d3-force/src/center.js
function center_default(x2, y2) {
  var nodes, strength = 1;
  if (x2 == null)
    x2 = 0;
  if (y2 == null)
    y2 = 0;
  function force() {
    var i2, n2 = nodes.length, node, sx = 0, sy = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n2 - x2) * strength, sy = (sy / n2 - y2) * strength, i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d2) {
  const x2 = +this._x.call(null, d2), y2 = +this._y.call(null, d2);
  return add(this.cover(x2, y2), x2, y2, d2);
}
function add(tree, x2, y2, d2) {
  if (isNaN(x2) || isNaN(y2))
    return tree;
  var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j3;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
    if (parent = node, !(node = node[i2 = bottom << 1 | right]))
      return parent[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x2 === xp && y2 === yp)
    return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
    if (right = x2 >= (xm = (x0 + x1) / 2))
      x0 = xm;
    else
      x1 = xm;
    if (bottom = y2 >= (ym = (y0 + y1) / 2))
      y0 = ym;
    else
      y1 = ym;
  } while ((i2 = bottom << 1 | right) === (j3 = (yp >= ym) << 1 | xp >= xm));
  return parent[j3] = node, parent[i2] = leaf, tree;
}
function addAll(data) {
  var d2, i2, n2 = data.length, x2, y2, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x2 = +this._x.call(null, d2 = data[i2])) || isNaN(y2 = +this._y.call(null, d2)))
      continue;
    xz[i2] = x2;
    yz[i2] = y2;
    if (x2 < x0)
      x0 = x2;
    if (x2 > x1)
      x1 = x2;
    if (y2 < y0)
      y0 = y2;
    if (y2 > y1)
      y1 = y2;
  }
  if (x0 > x1 || y0 > y1)
    return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i2 = 0; i2 < n2; ++i2) {
    add(this, xz[i2], yz[i2], data[i2]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2))
    return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x2)) + 1;
    y1 = (y0 = Math.floor(y2)) + 1;
  } else {
    var z = x1 - x0 || 1, node = this._root, parent, i2;
    while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1) {
      i2 = (y2 < y0) << 1 | x2 < x0;
      parent = new Array(4), parent[i2] = node, node = parent, z *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z, y1 = y0 + z;
          break;
        case 1:
          x0 = x1 - z, y1 = y0 + z;
          break;
        case 2:
          x1 = x0 + z, y0 = y1 - z;
          break;
        case 3:
          x0 = x1 - z, y0 = y1 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data.push(node.data);
      while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x2, y2, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q2, i2;
  if (node)
    quads.push(new quad_default(node, x0, y0, x3, y3));
  if (radius == null)
    radius = Infinity;
  else {
    x0 = x2 - radius, y0 = y2 - radius;
    x3 = x2 + radius, y3 = y2 + radius;
    radius *= radius;
  }
  while (q2 = quads.pop()) {
    if (!(node = q2.node) || (x1 = q2.x0) > x3 || (y1 = q2.y0) > y3 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0)
      continue;
    if (node.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(new quad_default(node[3], xm, ym, x22, y22), new quad_default(node[2], x1, ym, xm, y22), new quad_default(node[1], xm, y1, x22, ym), new quad_default(node[0], x1, y1, xm, ym));
      if (i2 = (y2 >= ym) << 1 | x2 >= xm) {
        q2 = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q2;
      }
    } else {
      var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d3 = Math.sqrt(radius = d2);
        x0 = x2 - d3, y0 = y2 - d3;
        x3 = x2 + d3, y3 = y2 + d3;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default(d2) {
  if (isNaN(x2 = +this._x.call(null, d2)) || isNaN(y2 = +this._y.call(null, d2)))
    return this;
  var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x2, y2, xm, ym, right, bottom, i2, j3;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x2 >= (xm = (x0 + x1) / 2))
        x0 = xm;
      else
        x1 = xm;
      if (bottom = y2 >= (ym = (y0 + y1) / 2))
        y0 = ym;
      else
        y1 = ym;
      if (!(parent = node, node = node[i2 = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3])
        retainer = parent, j3 = i2;
    }
  while (node.data !== d2)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i2] = next : delete parent[i2];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j3] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2)
    this.remove(data[i2]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q2, node = this._root, child, x0, y0, x1, y1;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q2;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    var node = q2.node;
    if (node.length) {
      var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d2) {
  return d2[0];
}
function x_default(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d2) {
  return d2[1];
}
function y_default(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x2, y2) {
  var tree = new Quadtree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x2, y2, x0, y0, x1, y1) {
  this._x = x2;
  this._y = y2;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy = { data: leaf.data }, next = copy;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy;
  if (!node.length)
    return copy._root = leaf_copy(node), copy;
  nodes = [{ source: node, target: copy._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i2 = 0; i2 < 4; ++i2) {
      if (child = node.source[i2]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i2] = new Array(4) });
        else
          node.target[i2] = leaf_copy(child);
      }
    }
  }
  return copy;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/link.js
function index(d2) {
  return d2.index;
}
function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id = index, strength = defaultStrength, strengths, distance = constant_default(30), distances, nodes, count, bias, random, iterations = 1;
  if (links == null)
    links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n2 = links.length; k2 < iterations; ++k2) {
      for (var i2 = 0, link, source, target, x2, y2, l, b; i2 < n2; ++i2) {
        link = links[i2], source = link.source, target = link.target;
        x2 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
        y2 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
        l = Math.sqrt(x2 * x2 + y2 * y2);
        l = (l - distances[i2]) / l * alpha * strengths[i2];
        x2 *= l, y2 *= l;
        target.vx -= x2 * (b = bias[i2]);
        target.vy -= y2 * b;
        source.vx += x2 * (b = 1 - b);
        source.vy += y2 * b;
      }
    }
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d2, i3) => [id(d2, i3, nodes), d2])), link;
    for (i2 = 0, count = new Array(n2); i2 < m2; ++i2) {
      link = links[i2], link.index = i2;
      if (typeof link.source !== "object")
        link.source = find(nodeById, link.source);
      if (typeof link.target !== "object")
        link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m2); i2 < m2; ++i2) {
      link = links[i2], bias[i2] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_2) {
    return arguments.length ? (links = _2, initialize(), force) : links;
  };
  force.id = function(_2) {
    return arguments.length ? (id = _2, force) : id;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, force) : iterations;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance = typeof _2 === "function" ? _2 : constant_default(+_2), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _2 = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _2 || /[\s.]/.test(t2))
      throw new Error("illegal type: " + t2);
    _2[t2] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0)
      name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    if (t2 && !types.hasOwnProperty(t2))
      throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T = parseTypenames(typename + "", _2), t2, i2 = -1, n2 = T.length;
    if (arguments.length < 2) {
      while (++i2 < n2)
        if ((t2 = (typename = T[i2]).type) && (t2 = get(_2[t2], typename.name)))
          return t2;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i2 < n2) {
      if (t2 = (typename = T[i2]).type)
        _2[t2] = set(_2[t2], typename.name, callback);
      else if (callback == null)
        for (t2 in _2)
          _2[t2] = set(_2[t2], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _2 = this._;
    for (var t2 in _2)
      copy[t2] = _2[t2].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0)
      for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2)
        args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2)
      t2[i2].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2)
      t2[i2].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i2 = 0, n2 = type.length, c3; i2 < n2; ++i2) {
    if ((c3 = type[i2]).name === name) {
      return c3.value;
    }
  }
}
function set(type, name, callback) {
  for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
    if (type[i2].name === name) {
      type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t2 = new Timer();
  t2.restart(callback, delay, time);
  return t2;
}
function timerFlush() {
  now();
  ++frame;
  var t2 = taskHead, e2;
  while (t2) {
    if ((e2 = clockNow - t2._time) >= 0)
      t2._call.call(null, e2);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-force/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}

// node_modules/d3-force/src/simulation.js
function x(d2) {
  return d2.x;
}
function y(d2) {
  return d2.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i2, n2 = nodes.length, node;
    if (iterations === void 0)
      iterations = 1;
    for (var k2 = 0; k2 < iterations; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node; i2 < n2; ++i2) {
      node = nodes[i2], node.index = i2;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i2), angle = i2 * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_2) {
      return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
    },
    find: function(x2, y2, radius) {
      var i2 = 0, n2 = nodes.length, dx, dy, d2, node, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node = nodes[i2];
        dx = x2 - node.x;
        dy = y2 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius)
          closest = node, radius = d2;
      }
      return closest;
    },
    on: function(name, _2) {
      return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random, alpha, strength = constant_default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i2, n2 = nodes.length, tree = quadtree(nodes, x, y).visitAfter(accumulate);
    for (alpha = _2, i2 = 0; i2 < n2; ++i2)
      node = nodes[i2], tree.visit(apply);
  }
  function initialize() {
    if (!nodes)
      return;
    var i2, n2 = nodes.length, node2;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2)
      node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q2, c3, weight = 0, x2, y2, i2;
    if (quad.length) {
      for (x2 = y2 = i2 = 0; i2 < 4; ++i2) {
        if ((q2 = quad[i2]) && (c3 = Math.abs(q2.value))) {
          strength2 += q2.value, weight += c3, x2 += c3 * q2.x, y2 += c3 * q2.y;
        }
      }
      quad.x = x2 / weight;
      quad.y = y2 / weight;
    } else {
      q2 = quad;
      q2.x = q2.data.x;
      q2.y = q2.data.y;
      do
        strength2 += strengths[q2.data.index];
      while (q2 = q2.next);
    }
    quad.value = strength2;
  }
  function apply(quad, x1, _2, x2) {
    if (!quad.value)
      return true;
    var x3 = quad.x - node.x, y2 = quad.y - node.y, w2 = x2 - x1, l = x3 * x3 + y2 * y2;
    if (w2 * w2 / theta2 < l) {
      if (l < distanceMax2) {
        if (x3 === 0)
          x3 = jiggle_default(random), l += x3 * x3;
        if (y2 === 0)
          y2 = jiggle_default(random), l += y2 * y2;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x3 * quad.value * alpha / l;
        node.vy += y2 * quad.value * alpha / l;
      }
      return true;
    } else if (quad.length || l >= distanceMax2)
      return;
    if (quad.data !== node || quad.next) {
      if (x3 === 0)
        x3 = jiggle_default(random), l += x3 * x3;
      if (y2 === 0)
        y2 = jiggle_default(random), l += y2 * y2;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad.data !== node) {
        w2 = strengths[quad.data.index] * alpha / l;
        node.vx += x3 * w2;
        node.vy += y2 * w2;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/@nivo/network/dist/nivo-network.es.js
function L() {
  return L = Object.assign ? Object.assign.bind() : function(e2) {
    for (var n2 = 1; n2 < arguments.length; n2++) {
      var i2 = arguments[n2];
      for (var o2 in i2)
        Object.prototype.hasOwnProperty.call(i2, o2) && (e2[o2] = i2[o2]);
    }
    return e2;
  }, L.apply(this, arguments);
}
function D(e2, n2) {
  if (e2 == null)
    return {};
  var i2, o2, t2 = {}, r2 = Object.keys(e2);
  for (o2 = 0; o2 < r2.length; o2++)
    i2 = r2[o2], n2.indexOf(i2) >= 0 || (t2[i2] = e2[i2]);
  return t2;
}
var E = (0, import_react.memo)(function(e2) {
  var n2 = e2.node, i2 = e2.animated, o2 = e2.onClick, t2 = e2.onMouseEnter, r2 = e2.onMouseMove, d2 = e2.onMouseLeave;
  return (0, import_jsx_runtime.jsx)(animated.circle, { "data-testid": "node." + n2.id, transform: to([i2.x, i2.y, i2.scale], function(e3, n3, i3) {
    return "translate(" + e3 + "," + n3 + ") scale(" + i3 + ")";
  }), r: to([i2.size], function(e3) {
    return e3 / 2;
  }), fill: i2.color, strokeWidth: i2.borderWidth, stroke: i2.borderColor, opacity: i2.opacity, onClick: o2 ? function(e3) {
    return o2(n2, e3);
  } : void 0, onMouseEnter: t2 ? function(e3) {
    return t2(n2, e3);
  } : void 0, onMouseMove: r2 ? function(e3) {
    return r2(n2, e3);
  } : void 0, onMouseLeave: d2 ? function(e3) {
    return d2(n2, e3);
  } : void 0 });
});
var R2 = (0, import_react.memo)(function(e2) {
  var n2 = e2.link, i2 = e2.animated, o2 = e2.blendMode;
  return (0, import_jsx_runtime.jsx)(animated.line, { "data-testid": "link." + n2.id, stroke: i2.color, style: { mixBlendMode: o2 }, strokeWidth: n2.thickness, strokeLinecap: "round", opacity: i2.opacity, x1: i2.x1, y1: i2.y1, x2: i2.x2, y2: i2.y2 });
});
var O = { layers: ["links", "nodes", "annotations"], linkDistance: 30, centeringStrength: 1, repulsivity: 10, distanceMin: 1, distanceMax: 1 / 0, iterations: 120, nodeSize: 12, activeNodeSize: 18, inactiveNodeSize: 8, nodeColor: "#000000", nodeBorderWidth: 0, nodeBorderColor: { from: "color" }, linkThickness: 1, linkColor: { from: "source.color" }, isInteractive: true, defaultActiveNodeIds: [], nodeTooltip: function(e2) {
  var n2 = e2.node;
  return (0, import_jsx_runtime.jsx)(w, { id: n2.id, enableChip: true, color: n2.color });
}, annotations: [], animate: true, motionConfig: "gentle", role: "img" };
var P = L({}, O, { nodeComponent: E, linkComponent: R2, linkBlendMode: "normal" });
var j2 = L({}, O, { renderNode: function(e2, n2) {
  e2.fillStyle = n2.color, e2.beginPath(), e2.arc(n2.x, n2.y, n2.size / 2, 0, 2 * Math.PI), e2.fill(), n2.borderWidth > 0 && (e2.strokeStyle = n2.borderColor, e2.lineWidth = n2.borderWidth, e2.stroke());
}, renderLink: function(e2, n2) {
  e2.strokeStyle = n2.color, e2.lineWidth = n2.thickness, e2.beginPath(), e2.moveTo(n2.source.x, n2.source.y), e2.lineTo(n2.target.x, n2.target.y), e2.stroke();
}, pixelRatio: typeof window != "undefined" && window.devicePixelRatio || 1 });
var H = ["index"];
var F = function(e2) {
  return (0, import_react.useMemo)(function() {
    return typeof e2 == "function" ? e2 : function() {
      return e2;
    };
  }, [e2]);
};
var q = function(e2) {
  var r2 = e2.center, d2 = e2.nodes, a3 = e2.links, c3 = e2.linkDistance, s = c3 === void 0 ? O.linkDistance : c3, u = e2.centeringStrength, v = u === void 0 ? O.centeringStrength : u, f = e2.repulsivity, h = f === void 0 ? O.repulsivity : f, k2 = e2.distanceMin, p = k2 === void 0 ? O.distanceMin : k2, m2 = e2.distanceMax, g = m2 === void 0 ? O.distanceMax : m2, y2 = e2.iterations, C2 = y2 === void 0 ? O.iterations : y2, M2 = e2.nodeSize, x2 = M2 === void 0 ? O.nodeSize : M2, z = e2.activeNodeSize, B = z === void 0 ? O.activeNodeSize : z, T = e2.inactiveNodeSize, w2 = T === void 0 ? O.inactiveNodeSize : T, A = e2.nodeColor, E2 = A === void 0 ? O.nodeColor : A, R3 = e2.nodeBorderWidth, P2 = R3 === void 0 ? O.nodeBorderWidth : R3, j3 = e2.nodeBorderColor, q2 = j3 === void 0 ? O.nodeBorderColor : j3, G2 = e2.linkThickness, J3 = G2 === void 0 ? O.linkThickness : G2, K2 = e2.linkColor, Q2 = K2 === void 0 ? O.linkColor : K2, U2 = e2.isInteractive, V2 = U2 === void 0 ? O.isInteractive : U2, X2 = e2.defaultActiveNodeIds, Y2 = X2 === void 0 ? O.defaultActiveNodeIds : X2, Z2 = (0, import_react.useState)(null), $2 = Z2[0], _2 = Z2[1], ee2 = (0, import_react.useState)(null), ne2 = ee2[0], ie2 = ee2[1], oe = function(e3) {
    var n2 = e3.linkDistance, i2 = e3.centeringStrength, t2 = e3.repulsivity, r3 = e3.distanceMin, d3 = e3.distanceMax, a4 = e3.center, c4 = F(n2), l = a4[0], s2 = a4[1];
    return (0, import_react.useMemo)(function() {
      return { link: link_default().distance(function(e4) {
        return c4(e4.data);
      }).strength(i2), charge: manyBody_default().strength(-t2).distanceMin(r3).distanceMax(d3), center: center_default(l, s2) };
    }, [c4, i2, t2, r3, d3, l, s2]);
  }({ linkDistance: s, centeringStrength: v, repulsivity: h, distanceMin: p, distanceMax: g, center: r2 });
  (0, import_react.useEffect)(function() {
    var e3 = d2.map(function(e4) {
      return { id: e4.id, data: L({}, e4), index: 0, x: 0, y: 0, vx: 0, vy: 0 };
    }), n2 = a3.map(function(n3) {
      return { data: L({}, n3), index: 0, source: e3.find(function(e4) {
        return e4.id === n3.source;
      }), target: e3.find(function(e4) {
        return e4.id === n3.target;
      }) };
    }), i2 = simulation_default(e3).force("link", oe.link.links(n2)).force("charge", oe.charge).force("center", oe.center).stop();
    return i2.tick(C2), _2(e3), ie2(n2), function() {
      i2.stop();
    };
  }, [d2, a3, oe, C2, _2, ie2]);
  var te = (0, import_react.useState)(Y2), re = te[0], de = te[1], ae = function(e3) {
    var n2 = e3.size, i2 = e3.activeSize, o2 = e3.inactiveSize, r3 = e3.color, d3 = e3.borderWidth, a4 = e3.borderColor, c4 = e3.isInteractive, s2 = e3.activeNodeIds, u2 = zt(), v2 = F(n2), f2 = F(r3), h2 = F(d3), k3 = Xe(a4, u2), p2 = (0, import_react.useCallback)(function(e4) {
      var n3 = f2(e4.data);
      return { size: v2(e4.data), color: n3, borderWidth: h2(e4.data), borderColor: k3(L({}, e4, { color: n3 })) };
    }, [v2, f2, h2, k3]), m3 = F(i2), g2 = (0, import_react.useCallback)(function(e4) {
      var n3 = f2(e4.data);
      return { size: m3(e4.data), color: n3, borderWidth: h2(e4.data), borderColor: k3(L({}, e4, { color: n3 })) };
    }, [m3, f2, h2, k3]), y3 = F(o2), C3 = (0, import_react.useCallback)(function(e4) {
      var n3 = f2(e4.data);
      return { size: y3(e4.data), color: n3, borderWidth: h2(e4.data), borderColor: k3(L({}, e4, { color: n3 })) };
    }, [y3, f2, h2, k3]);
    return (0, import_react.useCallback)(function(e4) {
      return c4 && s2.length !== 0 ? s2.includes(e4.id) ? g2(e4) : C3(e4) : p2(e4);
    }, [p2, g2, C3, c4, s2]);
  }({ size: x2, activeSize: B, inactiveSize: w2, color: E2, borderWidth: P2, borderColor: q2, isInteractive: V2, activeNodeIds: re }), ce = (0, import_react.useMemo)(function() {
    return $2 === null ? null : $2.map(function(e3) {
      return L({}, e3, ae(e3));
    });
  }, [$2, ae]), le = zt(), se = F(J3), ue = Xe(Q2, le), ve = (0, import_react.useMemo)(function() {
    return ne2 === null || ce === null ? null : ne2.map(function(e3) {
      var n2 = e3.index, i2 = D(e3, H), o2 = { id: i2.source.id + "." + i2.target.id, data: i2.data, index: n2, source: ce.find(function(e4) {
        return e4.id === i2.source.id;
      }), target: ce.find(function(e4) {
        return e4.id === i2.target.id;
      }) };
      return L({}, o2, { thickness: se(o2), color: ue(o2) });
    });
  }, [ne2, ce, se, ue]);
  return { nodes: ce, links: ve, activeNodeIds: re, setActiveNodeIds: de };
};
var G = function(e2) {
  return { x: e2.x, y: e2.y };
};
var J2 = function(e2) {
  return { size: e2.size, width: e2.size, height: e2.size };
};
var K = function(e2, n2) {
  return S({ data: e2, annotations: n2, getPosition: G, getDimensions: J2 });
};
var Q = function(e2) {
  var n2 = e2.links, i2 = e2.linkComponent, t2 = e2.blendMode, d2 = Ur(), a3 = d2.animate, c3 = d2.config, l = (0, import_react.useMemo)(function() {
    return [function(e3) {
      return { x1: e3.source.x, y1: e3.source.y, x2: e3.source.x, y2: e3.source.y, color: e3.color, opacity: 0 };
    }, function(e3) {
      return { x1: e3.source.x, y1: e3.source.y, x2: e3.target.x, y2: e3.target.y, color: e3.color, opacity: 1 };
    }];
  }, []), u = l[0], v = l[1], f = useTransition(n2, { keys: function(e3) {
    return e3.id;
  }, initial: v, from: u, enter: v, update: v, expires: true, config: c3, immediate: !a3 });
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: f(function(e3, n3) {
    return (0, import_react.createElement)(i2, { key: n3.id, link: n3, animated: e3, blendMode: t2 });
  }) });
};
var U = function(e2) {
  var n2 = e2.nodes, i2 = e2.nodeComponent, d2 = e2.onMouseEnter, a3 = e2.onMouseMove, c3 = e2.onMouseLeave, l = e2.onClick, u = e2.tooltip, v = e2.setActiveNodeIds, f = e2.isInteractive, h = Ur(), k2 = h.animate, p = h.config, m2 = (0, import_react.useMemo)(function() {
    return [function(e3) {
      return { x: e3.x, y: e3.y, size: e3.size, color: e3.color, borderWidth: e3.borderWidth, borderColor: e3.borderColor, scale: 0, opacity: 0 };
    }, function(e3) {
      return { x: e3.x, y: e3.y, size: e3.size, color: e3.color, borderWidth: e3.borderWidth, borderColor: e3.borderColor, scale: 1, opacity: 1 };
    }, function(e3) {
      return { x: e3.x, y: e3.y, size: e3.size, color: e3.color, borderWidth: e3.borderWidth, borderColor: e3.borderColor, scale: 0, opacity: 0 };
    }];
  }, []), g = m2[0], x2 = m2[1], b = m2[2], I = useTransition(n2, { keys: function(e3) {
    return e3.id;
  }, initial: x2, from: g, enter: x2, update: x2, leave: b, config: p, immediate: !k2 }), S2 = k(), N = S2.showTooltipFromEvent, W = S2.hideTooltip, B = (0, import_react.useCallback)(function(e3, n3) {
    N((0, import_react.createElement)(u, { node: e3 }), n3), v([e3.id]), d2 == null || d2(e3, n3);
  }, [N, u, v, d2]), T = (0, import_react.useCallback)(function(e3, n3) {
    N((0, import_react.createElement)(u, { node: e3 }), n3), a3 == null || a3(e3, n3);
  }, [N, u, a3]), w2 = (0, import_react.useCallback)(function(e3, n3) {
    W(), v([]), c3 == null || c3(e3, n3);
  }, [W, v, c3]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: I(function(e3, n3) {
    return (0, import_react.createElement)(i2, { key: n3.id, node: n3, animated: e3, onMouseEnter: f ? B : void 0, onMouseMove: f ? T : void 0, onMouseLeave: f ? w2 : void 0, onClick: f ? l : void 0 });
  }) });
};
var V = function(e2) {
  var n2 = e2.nodes, i2 = e2.annotations, o2 = K(n2, i2);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: o2.map(function(e3, n3) {
    return (0, import_jsx_runtime.jsx)(R, L({}, e3), n3);
  }) });
};
var X = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var Y = function(e2) {
  var n2 = e2.width, i2 = e2.height, t2 = e2.margin, a3 = e2.data, c3 = a3.nodes, l = a3.links, s = e2.linkDistance, u = s === void 0 ? P.linkDistance : s, h = e2.centeringStrength, k2 = h === void 0 ? P.centeringStrength : h, p = e2.repulsivity, m2 = p === void 0 ? P.repulsivity : p, g = e2.distanceMin, y2 = g === void 0 ? P.distanceMin : g, M2 = e2.distanceMax, x2 = M2 === void 0 ? P.distanceMax : M2, z = e2.iterations, b = z === void 0 ? P.iterations : z, I = e2.layers, S2 = I === void 0 ? P.layers : I, N = e2.nodeComponent, W = N === void 0 ? P.nodeComponent : N, B = e2.nodeSize, T = B === void 0 ? P.nodeSize : B, w2 = e2.activeNodeSize, A = w2 === void 0 ? P.activeNodeSize : w2, L2 = e2.inactiveNodeSize, D2 = L2 === void 0 ? P.inactiveNodeSize : L2, E2 = e2.nodeColor, R3 = E2 === void 0 ? P.nodeColor : E2, O2 = e2.nodeBorderWidth, j3 = O2 === void 0 ? P.nodeBorderWidth : O2, H2 = e2.nodeBorderColor, F2 = H2 === void 0 ? P.nodeBorderColor : H2, G2 = e2.linkComponent, J3 = G2 === void 0 ? P.linkComponent : G2, K2 = e2.linkThickness, X2 = K2 === void 0 ? P.linkThickness : K2, Y2 = e2.linkColor, Z2 = Y2 === void 0 ? P.linkColor : Y2, $2 = e2.linkBlendMode, _2 = $2 === void 0 ? P.linkBlendMode : $2, ee2 = e2.annotations, ne2 = ee2 === void 0 ? P.annotations : ee2, ie2 = e2.isInteractive, oe = ie2 === void 0 ? P.isInteractive : ie2, te = e2.defaultActiveNodeIds, re = te === void 0 ? P.defaultActiveNodeIds : te, de = e2.nodeTooltip, ae = de === void 0 ? P.nodeTooltip : de, ce = e2.onMouseEnter, le = e2.onMouseMove, se = e2.onMouseLeave, ue = e2.onClick, ve = e2.role, fe = ve === void 0 ? P.role : ve, he = e2.ariaLabel, ke = e2.ariaLabelledBy, pe = e2.ariaDescribedBy, me = wt(n2, i2, t2), ge = me.margin, ye = me.innerWidth, Ce = me.innerHeight, Me = me.outerWidth, xe = me.outerHeight, ze = q({ center: [ye / 2, Ce / 2], nodes: c3, links: l, linkDistance: u, centeringStrength: k2, repulsivity: m2, distanceMin: y2, distanceMax: x2, iterations: b, nodeSize: T, activeNodeSize: A, inactiveNodeSize: D2, nodeColor: R3, nodeBorderWidth: j3, nodeBorderColor: F2, linkThickness: X2, linkColor: Z2, isInteractive: oe, defaultActiveNodeIds: re }), be = ze.nodes, Ie = ze.links, Se = ze.activeNodeIds, Ne = ze.setActiveNodeIds, We = { links: null, nodes: null, annotations: null };
  S2.includes("links") && Ie !== null && (We.links = (0, import_jsx_runtime.jsx)(Q, { links: Ie, linkComponent: J3, blendMode: _2 }, "links")), S2.includes("nodes") && be !== null && (We.nodes = (0, import_jsx_runtime.jsx)(U, { nodes: be, nodeComponent: W, onMouseEnter: ce, onMouseMove: le, onMouseLeave: se, onClick: ue, tooltip: ae, setActiveNodeIds: Ne, isInteractive: oe }, "nodes")), S2.includes("annotations") && be !== null && (We.annotations = (0, import_jsx_runtime.jsx)(V, { nodes: be, annotations: ne2 }, "annotations"));
  var Be = (0, import_react.useMemo)(function() {
    return { nodes: be || [], links: Ie || [], activeNodeIds: Se, setActiveNodeIds: Ne };
  }, [be, Ie, Se, Ne]);
  return (0, import_jsx_runtime.jsx)(gn, { width: Me, height: xe, margin: ge, role: fe, ariaLabel: he, ariaLabelledBy: ke, ariaDescribedBy: pe, children: S2.map(function(e3, n3) {
    var i3;
    return typeof e3 == "function" ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: (0, import_react.createElement)(e3, Be) }, n3) : (i3 = We == null ? void 0 : We[e3]) != null ? i3 : null;
  }) });
};
var Z = function(e2) {
  var n2 = e2.isInteractive, i2 = n2 === void 0 ? P.isInteractive : n2, o2 = e2.animate, t2 = o2 === void 0 ? P.animate : o2, r2 = e2.motionConfig, d2 = r2 === void 0 ? P.motionConfig : r2, a3 = e2.theme, c3 = e2.renderWrapper, l = D(e2, X);
  return (0, import_jsx_runtime.jsx)(St, { animate: t2, isInteractive: i2, motionConfig: d2, renderWrapper: c3, theme: a3, children: (0, import_jsx_runtime.jsx)(Y, L({ isInteractive: i2 }, l)) });
};
var $ = function(e2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(n2) {
    var i2 = n2.width, o2 = n2.height;
    return (0, import_jsx_runtime.jsx)(Z, L({ width: i2, height: o2 }, e2));
  } });
};
var _ = ["theme", "isInteractive", "animate", "motionConfig", "renderWrapper"];
var ee = function(e2) {
  var n2 = e2.width, d2 = e2.height, a3 = e2.margin, s = e2.pixelRatio, u = s === void 0 ? j2.pixelRatio : s, f = e2.data, h = f.nodes, m2 = f.links, g = e2.linkDistance, y2 = g === void 0 ? j2.linkDistance : g, M2 = e2.centeringStrength, x2 = M2 === void 0 ? j2.centeringStrength : M2, b = e2.repulsivity, I = b === void 0 ? j2.repulsivity : b, S2 = e2.distanceMin, N = S2 === void 0 ? j2.distanceMin : S2, W = e2.distanceMax, B = W === void 0 ? j2.distanceMax : W, T = e2.iterations, L2 = T === void 0 ? j2.iterations : T, D2 = e2.layers, E2 = D2 === void 0 ? j2.layers : D2, R3 = e2.renderNode, O2 = R3 === void 0 ? j2.renderNode : R3, P2 = e2.nodeSize, H2 = P2 === void 0 ? j2.nodeSize : P2, F2 = e2.activeNodeSize, G2 = F2 === void 0 ? j2.activeNodeSize : F2, J3 = e2.inactiveNodeSize, Q2 = J3 === void 0 ? j2.inactiveNodeSize : J3, U2 = e2.nodeColor, V2 = U2 === void 0 ? j2.nodeColor : U2, X2 = e2.nodeBorderWidth, Y2 = X2 === void 0 ? j2.nodeBorderWidth : X2, Z2 = e2.nodeBorderColor, $2 = Z2 === void 0 ? j2.nodeBorderColor : Z2, _2 = e2.renderLink, ee2 = _2 === void 0 ? j2.renderLink : _2, ne2 = e2.linkThickness, ie2 = ne2 === void 0 ? j2.linkThickness : ne2, oe = e2.linkColor, te = oe === void 0 ? j2.linkColor : oe, re = e2.annotations, de = re === void 0 ? j2.annotations : re, ae = e2.isInteractive, ce = ae === void 0 ? j2.isInteractive : ae, le = e2.defaultActiveNodeIds, se = le === void 0 ? j2.defaultActiveNodeIds : le, ue = e2.nodeTooltip, ve = ue === void 0 ? j2.nodeTooltip : ue, fe = e2.onClick, he = e2.canvasRef, ke = (0, import_react.useRef)(null), pe = wt(n2, d2, a3), me = pe.margin, ge = pe.innerWidth, ye = pe.innerHeight, Ce = pe.outerWidth, Me = pe.outerHeight, xe = q({ center: [ge / 2, ye / 2], nodes: h, links: m2, linkDistance: y2, centeringStrength: x2, repulsivity: I, distanceMin: N, distanceMax: B, iterations: L2, nodeSize: H2, activeNodeSize: G2, inactiveNodeSize: Q2, nodeColor: V2, nodeBorderWidth: Y2, nodeBorderColor: $2, linkThickness: ie2, linkColor: te, isInteractive: ce, defaultActiveNodeIds: se }), ze = xe.nodes, be = xe.links, Ie = xe.activeNodeIds, Se = xe.setActiveNodeIds, Ne = K(ze, de), We = j({ annotations: Ne }), Be = (0, import_react.useMemo)(function() {
    return { nodes: ze || [], links: be || [], activeNodeIds: Ie, setActiveNodeIds: Se };
  }, [ze, be, Ie, Se]), Te = zt();
  (0, import_react.useEffect)(function() {
    if (ke.current !== null) {
      ke.current.width = Ce * u, ke.current.height = Me * u;
      var e3 = ke.current.getContext("2d");
      e3.scale(u, u), e3.fillStyle = Te.background, e3.fillRect(0, 0, Ce, Me), e3.translate(me.left, me.top), E2.forEach(function(n3) {
        n3 === "links" && be !== null ? be.forEach(function(n4) {
          return ee2(e3, n4);
        }) : n3 === "nodes" && ze !== null ? ze.forEach(function(n4) {
          return O2(e3, n4);
        }) : n3 === "annotations" ? J(e3, { annotations: We, theme: Te }) : typeof n3 == "function" && ze !== null && be !== null && n3(e3, Be);
      });
    }
  }, [ke, Ce, Me, me.left, me.top, u, E2, Te, ze, be, O2, ee2, We, Be]);
  var we = (0, import_react.useCallback)(function(e3) {
    if (ke.current && ze !== null) {
      var n3 = Sn(ke.current, e3), i2 = n3[0], o2 = n3[1];
      return ze.find(function(e4) {
        return Mn(e4.x, e4.y, i2 - me.left, o2 - me.top) <= e4.size / 2;
      });
    }
  }, [ke, me, ze]), Ae = k(), Le = Ae.showTooltipFromEvent, De = Ae.hideTooltip, Ee = (0, import_react.useCallback)(function(e3) {
    var n3 = we(e3);
    n3 ? (Le((0, import_react.createElement)(ve, { node: n3 }), e3), Se([n3.id])) : (De(), Se([]));
  }, [we, Le, ve, De, Se]), Re = (0, import_react.useCallback)(function() {
    De(), Se([]);
  }, [De, Se]), Oe = (0, import_react.useCallback)(function(e3) {
    if (fe) {
      var n3 = we(e3);
      n3 && fe(n3, e3);
    }
  }, [we, fe]);
  return (0, import_jsx_runtime.jsx)("canvas", { ref: function(e3) {
    ke.current = e3, he && "current" in he && (he.current = e3);
  }, width: Ce * u, height: Me * u, style: { width: Ce, height: Me, cursor: ce ? "auto" : "normal" }, onClick: ce ? Oe : void 0, onMouseEnter: ce ? Ee : void 0, onMouseLeave: ce ? Re : void 0, onMouseMove: ce ? Ee : void 0 });
};
var ne = (0, import_react.forwardRef)(function(e2, n2) {
  var i2 = e2.theme, o2 = e2.isInteractive, t2 = o2 === void 0 ? j2.isInteractive : o2, r2 = e2.animate, d2 = r2 === void 0 ? j2.animate : r2, a3 = e2.motionConfig, c3 = a3 === void 0 ? j2.motionConfig : a3, l = e2.renderWrapper, s = D(e2, _);
  return (0, import_jsx_runtime.jsx)(St, { isInteractive: t2, animate: d2, motionConfig: c3, theme: i2, renderWrapper: l, children: (0, import_jsx_runtime.jsx)(ee, L({ isInteractive: t2 }, s, { canvasRef: n2 })) });
});
var ie = (0, import_react.forwardRef)(function(e2, n2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(i2) {
    var o2 = i2.width, t2 = i2.height;
    return (0, import_jsx_runtime.jsx)(ne, L({ width: o2, height: t2 }, e2, { ref: n2 }));
  } });
});
export {
  Z as Network,
  ne as NetworkCanvas,
  $ as ResponsiveNetwork,
  ie as ResponsiveNetworkCanvas,
  j2 as canvasDefaultProps,
  O as commonDefaultProps,
  P as svgDefaultProps,
  q as useNetwork,
  K as useNodeAnnotations
};
//# sourceMappingURL=@nivo_network.js.map
