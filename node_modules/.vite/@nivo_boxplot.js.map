{
  "version": 3,
  "sources": ["../@nivo/boxplot/node_modules/@react-spring/web/src/index.ts", "../@nivo/boxplot/node_modules/@react-spring/web/src/applyAnimatedValues.ts", "../@nivo/boxplot/node_modules/@react-spring/web/src/AnimatedStyle.ts", "../@nivo/boxplot/node_modules/@react-spring/web/src/primitives.ts", "../@nivo/boxplot/src/BoxPlotAnnotations.tsx", "../@nivo/boxplot/src/BoxPlotLegends.tsx", "../@nivo/boxplot/src/BoxPlotItem.tsx", "../@nivo/boxplot/src/BoxPlotTooltip.tsx", "../@nivo/boxplot/src/props.ts", "../@nivo/boxplot/src/compute/generation.ts", "../@nivo/boxplot/src/compute/common.ts", "../@nivo/boxplot/src/compute/stratification.ts", "../@nivo/boxplot/src/hooks.ts", "../@nivo/boxplot/src/compute/legends.ts", "../@nivo/boxplot/src/BoxPlot.tsx", "../@nivo/boxplot/src/ResponsiveBoxPlot.tsx"],
  "sourcesContent": ["import { Globals } from '@react-spring/core'\nimport { unstable_batchedUpdates } from 'react-dom'\nimport { createStringInterpolator, colors } from '@react-spring/shared'\nimport { createHost } from '@react-spring/animated'\nimport { applyAnimatedValues } from './applyAnimatedValues'\nimport { AnimatedStyle } from './AnimatedStyle'\nimport { WithAnimated } from './animated'\nimport { primitives } from './primitives'\n\nGlobals.assign({\n  batchedUpdates: unstable_batchedUpdates,\n  createStringInterpolator,\n  colors,\n})\n\nconst host = createHost(primitives, {\n  applyAnimatedValues,\n  createAnimatedStyle: style => new AnimatedStyle(style),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props,\n})\n\nexport const animated = host.animated as WithAnimated\nexport { animated as a }\n\nexport * from './animated'\nexport * from '@react-spring/core'\n", "import { Lookup } from '@react-spring/types'\n\nconst isCustomPropRE = /^--/\n\ntype Value = string | number | boolean | null\n\nfunction dangerousStyleValue(name: string, value: Value) {\n  if (value == null || typeof value === 'boolean' || value === '') return ''\n  if (\n    typeof value === 'number' &&\n    value !== 0 &&\n    !isCustomPropRE.test(name) &&\n    !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])\n  )\n    return value + 'px'\n  // Presumes implicit 'px' suffix for unitless numbers\n  return ('' + value).trim()\n}\n\nconst attributeCache: Lookup<string> = {}\n\ntype Instance = HTMLDivElement & { style?: Lookup }\n\nexport function applyAnimatedValues(instance: Instance, props: Lookup) {\n  if (!instance.nodeType || !instance.setAttribute) {\n    return false\n  }\n\n  const isFilterElement =\n    instance.nodeName === 'filter' ||\n    (instance.parentNode && instance.parentNode.nodeName === 'filter')\n\n  const {\n    className,\n    style,\n    children,\n    scrollTop,\n    scrollLeft,\n    viewBox,\n    ...attributes\n  } = props!\n\n  const values = Object.values(attributes)\n  const names = Object.keys(attributes).map(name =>\n    isFilterElement || instance.hasAttribute(name)\n      ? name\n      : attributeCache[name] ||\n        (attributeCache[name] = name.replace(\n          /([A-Z])/g,\n          // Attributes are written in dash case\n          n => '-' + n.toLowerCase()\n        ))\n  )\n\n  if (children !== void 0) {\n    instance.textContent = children\n  }\n\n  // Apply CSS styles\n  for (const name in style) {\n    if (style.hasOwnProperty(name)) {\n      const value = dangerousStyleValue(name, style[name])\n      if (isCustomPropRE.test(name)) {\n        instance.style.setProperty(name, value)\n      } else {\n        instance.style[name] = value\n      }\n    }\n  }\n\n  // Apply DOM attributes\n  names.forEach((name, i) => {\n    instance.setAttribute(name, values[i])\n  })\n\n  if (className !== void 0) {\n    instance.className = className\n  }\n  if (scrollTop !== void 0) {\n    instance.scrollTop = scrollTop\n  }\n  if (scrollLeft !== void 0) {\n    instance.scrollLeft = scrollLeft\n  }\n  if (viewBox !== void 0) {\n    instance.setAttribute('viewBox', viewBox)\n  }\n}\n\nlet isUnitlessNumber: { [key: string]: true } = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true,\n}\n\nconst prefixKey = (prefix: string, key: string) =>\n  prefix + key.charAt(0).toUpperCase() + key.substring(1)\nconst prefixes = ['Webkit', 'Ms', 'Moz', 'O']\n\nisUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {\n  prefixes.forEach(prefix => (acc[prefixKey(prefix, prop)] = acc[prop]))\n  return acc\n}, isUnitlessNumber)\n", "import { AnimatedObject } from '@react-spring/animated'\nimport { Lookup, OneOrMore } from '@react-spring/types'\nimport {\n  is,\n  each,\n  toArray,\n  eachProp,\n  FluidValue,\n  FluidEvent,\n  getFluidValue,\n  callFluidObservers,\n  hasFluidValue,\n  addFluidObserver,\n  removeFluidObserver,\n} from '@react-spring/shared'\n\n/** The transform-functions\n * (https://developer.mozilla.org/fr/docs/Web/CSS/transform-function)\n * that you can pass as keys to your animated component style and that will be\n * animated. Perspective has been left out as it would conflict with the\n * non-transform perspective style.\n */\nconst domTransforms = /^(matrix|translate|scale|rotate|skew)/\n\n// These keys have \"px\" units by default\nconst pxTransforms = /^(translate)/\n\n// These keys have \"deg\" units by default\nconst degTransforms = /^(rotate|skew)/\n\ntype Value = number | string\n\n/** Add a unit to the value when the value is unit-less (eg: a number) */\nconst addUnit = (value: Value, unit: string): string | 0 =>\n  is.num(value) && value !== 0 ? value + unit : value\n\n/**\n * Checks if the input value matches the identity value.\n *\n *     isValueIdentity(0, 0)              // => true\n *     isValueIdentity('0px', 0)          // => true\n *     isValueIdentity([0, '0px', 0], 0)  // => true\n */\nconst isValueIdentity = (value: OneOrMore<Value>, id: number): boolean =>\n  is.arr(value)\n    ? value.every(v => isValueIdentity(v, id))\n    : is.num(value)\n      ? value === id\n      : parseFloat(value) === id\n\ntype Inputs = ReadonlyArray<Value | FluidValue<Value>>[]\ntype Transforms = ((value: any) => [string, boolean])[]\n\n/**\n * This AnimatedStyle will simplify animated components transforms by\n * interpolating all transform function passed as keys in the style object\n * including shortcuts such as x, y and z for translateX/Y/Z\n */\nexport class AnimatedStyle extends AnimatedObject {\n  constructor({ x, y, z, ...style }: Lookup) {\n    /**\n     * An array of arrays that contains the values (static or fluid)\n     * used by each transform function.\n     */\n    const inputs: Inputs = []\n    /**\n     * An array of functions that take a list of values (static or fluid)\n     * and returns (1) a CSS transform string and (2) a boolean that's true\n     * when the transform has no effect (eg: an identity transform).\n     */\n    const transforms: Transforms = []\n\n    // Combine x/y/z into translate3d\n    if (x || y || z) {\n      inputs.push([x || 0, y || 0, z || 0])\n      transforms.push((xyz: Value[]) => [\n        `translate3d(${xyz.map(v => addUnit(v, 'px')).join(',')})`, // prettier-ignore\n        isValueIdentity(xyz, 0),\n      ])\n    }\n\n    // Pluck any other transform-related props\n    eachProp(style, (value, key) => {\n      if (key === 'transform') {\n        inputs.push([value || ''])\n        transforms.push((transform: string) => [transform, transform === ''])\n      } else if (domTransforms.test(key)) {\n        delete style[key]\n        if (is.und(value)) return\n\n        const unit = pxTransforms.test(key)\n          ? 'px'\n          : degTransforms.test(key)\n            ? 'deg'\n            : ''\n\n        inputs.push(toArray(value))\n        transforms.push(\n          key === 'rotate3d'\n            ? ([x, y, z, deg]: [number, number, number, Value]) => [\n                `rotate3d(${x},${y},${z},${addUnit(deg, unit)})`,\n                isValueIdentity(deg, 0),\n              ]\n            : (input: Value[]) => [\n                `${key}(${input.map(v => addUnit(v, unit)).join(',')})`,\n                isValueIdentity(input, key.startsWith('scale') ? 1 : 0),\n              ]\n        )\n      }\n    })\n\n    if (inputs.length) {\n      style.transform = new FluidTransform(inputs, transforms)\n    }\n\n    super(style)\n  }\n}\n\n/** @internal */\nclass FluidTransform extends FluidValue<string> {\n  protected _value: string | null = null\n\n  constructor(\n    readonly inputs: Inputs,\n    readonly transforms: Transforms\n  ) {\n    super()\n  }\n\n  get() {\n    return this._value || (this._value = this._get())\n  }\n\n  protected _get() {\n    let transform = ''\n    let identity = true\n    each(this.inputs, (input, i) => {\n      const arg1 = getFluidValue(input[0])\n      const [t, id] = this.transforms[i](\n        is.arr(arg1) ? arg1 : input.map(getFluidValue)\n      )\n      transform += ' ' + t\n      identity = identity && id\n    })\n    return identity ? 'none' : transform\n  }\n\n  // Start observing our inputs once we have an observer.\n  protected observerAdded(count: number) {\n    if (count == 1)\n      each(this.inputs, input =>\n        each(\n          input,\n          value => hasFluidValue(value) && addFluidObserver(value, this)\n        )\n      )\n  }\n\n  // Stop observing our inputs once we have no observers.\n  protected observerRemoved(count: number) {\n    if (count == 0)\n      each(this.inputs, input =>\n        each(\n          input,\n          value => hasFluidValue(value) && removeFluidObserver(value, this)\n        )\n      )\n  }\n\n  eventObserved(event: FluidEvent) {\n    if (event.type == 'change') {\n      this._value = null\n    }\n    callFluidObservers(this, event)\n  }\n}\n", "export type Primitives = keyof JSX.IntrinsicElements\nexport const primitives: Primitives[] = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  // SVG\n  'circle',\n  'clipPath',\n  'defs',\n  'ellipse',\n  'foreignObject',\n  'g',\n  'image',\n  'line',\n  'linearGradient',\n  'mask',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialGradient',\n  'rect',\n  'stop',\n  'svg',\n  'text',\n  'tspan',\n]\n", "import { Annotation, useAnnotations } from '@nivo/annotations'\nimport { BoxPlotAnnotationsProps, ComputedBoxPlotSummary } from './types'\n\nconst getPosition = (boxPlot: ComputedBoxPlotSummary) => ({\n    x: boxPlot.x + boxPlot.width / 2,\n    y: boxPlot.y + boxPlot.height / 2,\n})\n\nconst getDimensions = ({ width, height }: { width: number; height: number }) => ({\n    width,\n    height,\n    size: Math.max(width, height),\n})\n\nexport const BoxPlotAnnotations = ({ boxPlots, annotations }: BoxPlotAnnotationsProps) => {\n    const boundAnnotations = useAnnotations({\n        data: boxPlots,\n        annotations,\n        getPosition,\n        getDimensions,\n    })\n\n    return (\n        <>\n            {boundAnnotations.map((annotation, i) => (\n                <Annotation key={i} {...annotation} />\n            ))}\n        </>\n    )\n}\n", "import { BoxLegendSvg, LegendProps } from '@nivo/legends'\nimport { LegendData } from './types'\n\ninterface BoxPlotLegendsProps {\n    width: number\n    height: number\n    legends: [LegendProps, LegendData[]][]\n}\n\nexport const BoxPlotLegends = ({ width, height, legends }: BoxPlotLegendsProps) => (\n    <>\n        {legends.map(([legend, data], i) => {\n            // Advanced feature:\n            // Allow a legend spec to carry its own custom content via 'legend.data'\n            // Or fallback on content provided via 'data'\n            return (\n                <BoxLegendSvg\n                    key={i}\n                    {...legend}\n                    containerWidth={width}\n                    containerHeight={height}\n                    data={legend.data ?? data}\n                />\n            )\n        })}\n    </>\n)\n", "import { createElement, MouseEvent, useCallback, useMemo } from 'react'\nimport { animated, SpringValue } from '@react-spring/web'\nimport { useTooltip } from '@nivo/tooltip'\nimport { BoxPlotDatum, BoxPlotItemProps } from './types'\n\nconst BoxPlotItemWhisker = ({\n    distStart,\n    distEnd,\n    whiskerEndSize,\n    whiskerColor,\n    whiskerWidth,\n}: {\n    distStart: SpringValue<number>\n    distEnd: SpringValue<number>\n    whiskerEndSize: number\n    whiskerColor: SpringValue<string>\n    whiskerWidth: number\n}) => {\n    return (\n        <>\n            <animated.line\n                x1={0}\n                x2={0}\n                y1={distStart}\n                y2={distEnd}\n                strokeWidth={whiskerWidth}\n                stroke={whiskerColor}\n            />\n            {whiskerEndSize > 0 ? (\n                <animated.line\n                    x1={-whiskerEndSize}\n                    x2={whiskerEndSize}\n                    y1={distEnd}\n                    y2={distEnd}\n                    strokeWidth={whiskerWidth}\n                    stroke={whiskerColor}\n                />\n            ) : null}\n        </>\n    )\n}\n\nexport const BoxPlotItem = <RawDatum extends BoxPlotDatum>({\n    boxPlot,\n    layout,\n    animatedProps: {\n        borderColor,\n        medianColor,\n        whiskerColor,\n        color,\n        opacity,\n        transform,\n        valueInterval,\n        valueDistance0,\n        valueDistance1,\n        valueDistance3,\n        valueDistance4,\n    },\n    borderRadius,\n    borderWidth,\n    medianWidth,\n    whiskerWidth,\n    whiskerEndSize,\n    isInteractive,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    setActiveItem,\n    tooltip,\n    isFocusable,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n}: BoxPlotItemProps<RawDatum>) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const vertical = layout === 'vertical'\n    const bandwidth = vertical ? boxPlot.width : boxPlot.height\n\n    const renderTooltip = useMemo(() => () => createElement(tooltip, boxPlot), [tooltip, boxPlot])\n\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onClick?.(boxPlot, event)\n        },\n        [boxPlot, onClick]\n    )\n    const handleTooltip = useCallback(\n        (event: MouseEvent<SVGRectElement>) => showTooltipFromEvent(renderTooltip(), event),\n        [showTooltipFromEvent, renderTooltip]\n    )\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseEnter?.(boxPlot, event)\n            showTooltipFromEvent(renderTooltip(), event)\n            setActiveItem(boxPlot)\n        },\n        [boxPlot, onMouseEnter, showTooltipFromEvent, renderTooltip, setActiveItem]\n    )\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseLeave?.(boxPlot, event)\n            hideTooltip()\n            setActiveItem(null)\n        },\n        [boxPlot, hideTooltip, onMouseLeave, setActiveItem]\n    )\n    const handleBlur = useCallback(() => {\n        hideTooltip()\n    }, [hideTooltip])\n\n    return (\n        <animated.g\n            data-key={`boxplot.${boxPlot.key}`}\n            transform={transform}\n            opacity={opacity}\n            onMouseEnter={isInteractive ? handleMouseEnter : undefined}\n            onMouseMove={isInteractive ? handleTooltip : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n            onBlur={isInteractive && isFocusable ? handleBlur : undefined}\n            focusable={isFocusable}\n            tabIndex={isFocusable ? 0 : undefined}\n            aria-label={ariaLabel ? ariaLabel(boxPlot) : undefined}\n            aria-labelledby={ariaLabelledBy ? ariaLabelledBy(boxPlot) : undefined}\n            aria-describedby={ariaDescribedBy ? ariaDescribedBy(boxPlot) : undefined}\n        >\n            <animated.rect\n                x={-bandwidth / 2}\n                y={vertical ? valueDistance3 : valueDistance1}\n                width={bandwidth}\n                height={valueInterval}\n                rx={borderRadius}\n                ry={borderRadius}\n                fill={boxPlot.fill ?? color}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n            />\n            <animated.line\n                x1={-bandwidth / 2}\n                x2={bandwidth / 2}\n                y1={0}\n                y2={0}\n                strokeWidth={medianWidth}\n                stroke={medianColor}\n            />\n            <BoxPlotItemWhisker\n                distStart={valueDistance1}\n                distEnd={valueDistance0}\n                whiskerEndSize={(whiskerEndSize * bandwidth) / 2}\n                whiskerColor={whiskerColor}\n                whiskerWidth={whiskerWidth}\n            />\n            <BoxPlotItemWhisker\n                distStart={valueDistance3}\n                distEnd={valueDistance4}\n                whiskerEndSize={(whiskerEndSize * bandwidth) / 2}\n                whiskerColor={whiskerColor}\n                whiskerWidth={whiskerWidth}\n            />\n        </animated.g>\n    )\n}\n", "import { BoxPlotSummaryFormatted, BoxPlotTooltipProps, BoxPlotSummary } from './types'\nimport { Chip } from '@nivo/tooltip'\nimport { memo } from 'react'\nimport { useTheme, CompleteTheme } from '@nivo/core'\n\ninterface BoxPlotSummaryTooltipProps {\n    label: string\n    formatted: BoxPlotSummaryFormatted\n    color?: string\n    enableChip?: boolean\n}\n\ninterface Translation {\n    [key: string]: number | string\n}\n\nexport const defaultTranslation = {\n    n: 'n',\n    mean: 'mean',\n    min: 'min',\n    max: 'max',\n    Summary: 'Summary',\n    Quantiles: 'Quantiles',\n}\n\ntype ExtendedTheme = CompleteTheme & {\n    translation: Translation\n}\n\nconst hasTranslation = (theme: CompleteTheme | ExtendedTheme): theme is ExtendedTheme => {\n    return 'translation' in theme\n}\n\nexport const BoxPlotSummaryTooltip = memo<BoxPlotSummaryTooltipProps>(\n    ({ label, formatted, enableChip = false, color }) => {\n        const theme = useTheme()\n        let translation = defaultTranslation\n        if (hasTranslation(theme)) {\n            translation = {\n                ...defaultTranslation,\n                ...theme.translation,\n            }\n        }\n\n        const quantiles = formatted.quantiles.map((q, i) => (\n            <div key={'quantile.' + i}>\n                {q}%: <strong>{formatted.values[i]}</strong>\n            </div>\n        ))\n        return (\n            <div style={theme.tooltip.container}>\n                <div style={theme.tooltip.basic}>\n                    {enableChip && <Chip color={color ?? ''} style={theme.tooltip.chip} />}\n                    {label}\n                </div>\n                <div style={{ display: 'flex', marginTop: '1rem' }}>\n                    <div style={{ marginRight: '2rem' }}>\n                        <div>\n                            {translation.n}: <strong>{formatted.n}</strong>\n                        </div>\n                        <div style={{ marginTop: '1rem' }}>{translation.Summary}</div>\n                        <div>\n                            {translation.mean}: <strong>{formatted.mean}</strong>\n                        </div>\n                        <div>\n                            {translation.min}: <strong>{formatted.extrema[0]}</strong>\n                        </div>\n                        <div>\n                            {translation.max}: <strong>{formatted.extrema[1]}</strong>\n                        </div>\n                    </div>\n                    <div>\n                        <div>{translation.Quantiles}</div>\n                        {quantiles}\n                    </div>\n                </div>\n            </div>\n        )\n    }\n)\n\nexport const BoxPlotTooltip = ({ color, label, formatted }: BoxPlotTooltipProps) => {\n    return (\n        <BoxPlotSummaryTooltip\n            label={label}\n            formatted={formatted}\n            enableChip={true}\n            color={color}\n        />\n    )\n}\n\nexport const BoxPlotTooltipLabel = (datum: BoxPlotSummary) => {\n    if (datum.subGroup) {\n        return datum.group + ' - ' + datum.subGroup\n    }\n    return datum.group\n}\n", "import { BoxPlotItem } from './BoxPlotItem'\nimport { BoxPlotTooltip, BoxPlotTooltipLabel } from './BoxPlotTooltip'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { ScaleBandSpec, ScaleLinearSpec } from '@nivo/scales'\nimport { ComputedBoxPlotSummary } from './types'\n\nexport const defaultProps = {\n    value: 'value',\n    groupBy: 'group',\n    groups: null,\n    subGroupBy: null,\n    subGroups: null,\n\n    quantiles: [0.1, 0.25, 0.5, 0.75, 0.9],\n\n    layout: 'vertical' as const,\n\n    minValue: 'auto' as const,\n    maxValue: 'auto' as const,\n\n    valueScale: { type: 'linear' } as ScaleLinearSpec,\n    indexScale: { type: 'band', round: true } as ScaleBandSpec,\n\n    padding: 0.1,\n    innerPadding: 6,\n\n    opacity: 1,\n    activeOpacity: 1,\n    inactiveOpacity: 0.25,\n\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: false,\n    enableGridY: true,\n\n    valueFormat: (value: number) => value.toPrecision(4),\n\n    colorBy: 'subGroup' as const,\n    colors: { scheme: 'nivo' } as OrdinalColorScaleConfig,\n\n    borderRadius: 0,\n    borderWidth: 0,\n    borderColor: { from: 'color' } as InheritedColorConfig<ComputedBoxPlotSummary>,\n\n    medianWidth: 3,\n    medianColor: {\n        from: 'color',\n        modifiers: [['darker', 2.0]],\n    } as InheritedColorConfig<ComputedBoxPlotSummary>,\n\n    whiskerWidth: 2,\n    whiskerColor: {\n        from: 'color',\n    } as InheritedColorConfig<ComputedBoxPlotSummary>,\n    whiskerEndSize: 0,\n\n    isInteractive: true,\n    tooltip: BoxPlotTooltip,\n    tooltipLabel: BoxPlotTooltipLabel,\n\n    legends: [],\n    annotations: [],\n    markers: [],\n}\n\nexport const svgDefaultProps = {\n    ...defaultProps,\n    layers: ['grid', 'axes', 'boxPlots', 'markers', 'legends', 'annotations'],\n    boxPlotComponent: BoxPlotItem,\n\n    defs: [],\n    fill: [],\n\n    animate: true,\n    motionConfig: 'default',\n\n    role: 'img',\n    isFocusable: false,\n}\n", "import {\n    Scale,\n    ScaleBand,\n    computeScale,\n    ScaleBandSpec,\n    ScaleLinearSpec,\n    ScaleLogSpec,\n    ScaleSymlogSpec,\n    ScaleTimeSpec,\n} from '@nivo/scales'\nimport { BoxPlotSummary, ComputedBoxPlotSummary } from '../types'\nimport { getIndexScale } from './common'\n\ntype Params = {\n    data: BoxPlotSummary[]\n    formatValue: (value: number) => string\n    getTooltipLabel: (datum: BoxPlotSummary) => string\n    innerPadding: number\n    groups: string[]\n    subGroups: string[]\n    indexScale: ScaleBand<string>\n    valueScale: Scale<number, number>\n    bandwidth: number\n    layout: 'vertical' | 'horizontal'\n}\n\nconst generateComputedBoxPlotSummaries = ({\n    data,\n    getTooltipLabel,\n    innerPadding = 0,\n    groups,\n    indexScale,\n    valueScale,\n    formatValue,\n    bandwidth,\n    layout,\n}: Params): ComputedBoxPlotSummary[] => {\n    if (bandwidth === 0) {\n        return Array<ComputedBoxPlotSummary>()\n    }\n    const vertical = layout === 'vertical'\n    return data.map(datum => {\n        const { group, subGroup, groupIndex, subGroupIndex, values } = datum\n        const indexCoordinate =\n            (indexScale(groups[groupIndex]) ?? 0) +\n            bandwidth * subGroupIndex +\n            innerPadding * subGroupIndex\n        const key = `${groupIndex}.${subGroupIndex}`\n        const coords = values.map(valueScale).map(v => v ?? 0)\n        const intervals = [0, 1, 2, 3].map(i => Math.abs(coords[i + 1] - coords[i]) ?? 0)\n        // top-left of rectangle and width/height depend on the layout\n        // (this conditional inside the loop is not ideal, but typical loops will be short)\n        const position = vertical\n            ? {\n                  x: indexCoordinate,\n                  y: valueScale(datum.values[3]) ?? 0,\n                  width: bandwidth,\n                  height: intervals[1] + intervals[2],\n              }\n            : {\n                  x: valueScale(datum.values[1]) ?? 0,\n                  y: indexCoordinate,\n                  width: intervals[1] + intervals[2],\n                  height: bandwidth,\n              }\n        return {\n            key,\n            group,\n            subGroup,\n            data: datum,\n            formatted: {\n                n: String(datum.n),\n                mean: formatValue(datum.mean),\n                extrema: datum.extrema.map(formatValue),\n                values: datum.values.map(formatValue),\n                quantiles: datum.quantiles.map(v => String(100 * v)),\n            },\n            ...position,\n            coordinates: {\n                index: indexCoordinate,\n                values: values.map(v => valueScale(v) ?? 0),\n            },\n            bandwidth,\n            label: getTooltipLabel(datum),\n            layout,\n        } as ComputedBoxPlotSummary\n    })\n}\n\nexport const generateBoxPlots = ({\n    data,\n    layout,\n    groups,\n    subGroups,\n    formatValue,\n    minValue,\n    maxValue,\n    width,\n    height,\n    padding,\n    innerPadding,\n    valueScale: valueScaleConfig,\n    indexScale: indexScaleConfig,\n    getTooltipLabel,\n}: {\n    data: BoxPlotSummary[]\n    layout: string\n    groups: string[] | null\n    subGroups: string[] | null\n    formatValue: (value: number) => string\n    minValue: 'auto' | number\n    maxValue: 'auto' | number\n    width: number\n    height: number\n    padding: number\n    innerPadding: number\n    valueScale: ScaleLinearSpec | ScaleLogSpec | ScaleSymlogSpec | ScaleTimeSpec\n    indexScale: ScaleBandSpec\n    getTooltipLabel: (datum: BoxPlotSummary) => string\n}) => {\n    const [axis, otherAxis, size] =\n        layout === 'vertical' ? (['y', 'x', width] as const) : (['x', 'y', height] as const)\n    const indexScale = getIndexScale(groups ?? [], padding, indexScaleConfig, size, otherAxis)\n\n    const valueScaleSpec = {\n        max: maxValue,\n        min: minValue,\n        ...valueScaleConfig,\n    }\n\n    const values = data.map((datum: BoxPlotSummary) => datum.values).flat()\n    const min = values.reduce((acc: number, value: number) => Math.min(acc, value), Infinity)\n    const max = values.reduce((acc: number, value: number) => Math.max(acc, value), -Infinity)\n\n    const valueScale = computeScale(\n        valueScaleSpec as ScaleLinearSpec | ScaleLogSpec | ScaleSymlogSpec | ScaleTimeSpec,\n        { all: [min, max], min, max },\n        axis === 'x' ? width : height,\n        axis\n    )\n\n    const [xScale, yScale] =\n        layout === 'vertical' ? [indexScale, valueScale] : [valueScale, indexScale]\n\n    const nSubGroups = Math.max(1, subGroups ? subGroups.length : 1)\n    const bandwidth = (indexScale.bandwidth() - innerPadding * (nSubGroups - 1)) / nSubGroups\n\n    const params = {\n        data,\n        groups,\n        subGroups,\n        getTooltipLabel,\n        innerPadding,\n        indexScale,\n        valueScale,\n        formatValue,\n        bandwidth,\n        layout,\n    } as Params\n    const boxPlots = generateComputedBoxPlotSummaries(params)\n\n    return { xScale, yScale, boxPlots }\n}\n", "import { ScaleBandSpec, ScaleBand, computeScale } from '@nivo/scales'\n\n/**\n * Generates indexed scale.\n */\nexport const getIndexScale = (\n    groups: string[],\n    padding: number,\n    indexScale: ScaleBandSpec,\n    size: number,\n    axis: 'x' | 'y'\n) => {\n    return (\n        computeScale(indexScale, { all: groups, min: 0, max: 0 }, size, axis) as ScaleBand<string>\n    ).padding(padding)\n}\n", "import { BoxPlotDatum, BoxPlotCommonProps, BoxPlotSummary } from '../types'\nimport { defaultProps } from '../props'\n\n/** stratify an array of raw data objects into an array of arrays;\n * each array will create one box plot */\nexport const stratifyData = <RawDatum extends BoxPlotDatum>({\n    data,\n    groups = defaultProps.groups,\n    getGroup,\n    subGroups = defaultProps.subGroups,\n    getSubGroup,\n}: {\n    data: RawDatum[]\n    groups?: BoxPlotCommonProps<RawDatum>['groups']\n    getGroup: ((datum: RawDatum) => string) | null\n    subGroups?: BoxPlotCommonProps<RawDatum>['subGroups']\n    getSubGroup: ((datum: RawDatum) => string) | null\n}) => {\n    const groupsMap = {} as BoxPlotDatum\n    if (groups) {\n        groups.map((g, i) => (groupsMap[g] = i))\n    }\n    const subGroupsMap = {} as BoxPlotDatum\n    if (subGroups) {\n        subGroups.map((sg, i) => (subGroupsMap[sg] = i))\n    }\n\n    const nGroups = Math.max(1, groups ? groups.length : 1)\n    const nSubGroups = Math.max(1, subGroups ? subGroups.length : 1)\n    const n = nGroups * nSubGroups\n    const result = Array(n)\n        .fill([])\n        .map(() => Array<RawDatum>())\n    data.forEach((d: RawDatum) => {\n        const groupIndex = getGroup ? Number(groupsMap[getGroup(d)]) : 0\n        const subGroupIndex = getSubGroup ? Number(subGroupsMap[getSubGroup(d)] ?? 0) : 0\n        const index = groupIndex * nSubGroups + subGroupIndex\n        if (index >= 0) {\n            result[index].push(d)\n        }\n    })\n    return result\n}\n\nconst getQuantile = (values: number[], quantile = 0.5) => {\n    const realIndex = (values.length - 1) * Math.max(0, Math.min(1, quantile))\n    const intIndex = Math.floor(realIndex)\n    if (realIndex === intIndex) return values[intIndex]\n    const v1 = values[intIndex],\n        v2 = values[intIndex + 1]\n    return v1 + (v2 - v1) * (realIndex - intIndex)\n}\n\nconst getMean = (values: number[]) => {\n    const sum = values.reduce((acc, x) => acc + x, 0)\n    return sum / values.length\n}\n\nconst isPrecomputedDistribution = <RawDatum>(\n    datum: RawDatum | Omit<BoxPlotSummary, 'groupIndex' | 'subGroupIndex'>\n): datum is Omit<BoxPlotSummary, 'groupIndex' | 'subGroupIndex'> => {\n    const preComputedKeys = ['values', 'extrema', 'mean', 'quantiles', 'group', 'subGroup', 'n']\n    return preComputedKeys.every(k => k in (datum as object))\n}\n\nexport const summarizeDistribution = <RawDatum extends BoxPlotDatum>({\n    data,\n    getValue,\n    groups,\n    subGroups,\n    groupIndex,\n    subGroupIndex,\n    quantiles,\n}: {\n    data: RawDatum[]\n    getValue: (datum: RawDatum) => unknown\n    groups: string[] | null\n    subGroups: string[] | null\n    groupIndex: number\n    subGroupIndex: number\n    quantiles: number[]\n}) => {\n    // accept a precomputed summary representation if it has all the required keys\n    if (data.length === 1 && isPrecomputedDistribution(data[0])) {\n        return {\n            groupIndex: groupIndex,\n            subGroupIndex: subGroupIndex,\n            ...data[0],\n        } as BoxPlotSummary\n    }\n    // compute the summary representation from raw data using quantiles\n    const values = data.map(v => Number(getValue(v))) as number[]\n    values.sort((a, b) => a - b)\n    return {\n        group: groups ? groups[groupIndex] : '',\n        groupIndex: groupIndex,\n        subGroup: subGroups ? subGroups[subGroupIndex] : '',\n        subGroupIndex: subGroupIndex,\n        n: values.length,\n        extrema: [values[0], values[values.length - 1]],\n        quantiles: quantiles,\n        values: quantiles.map(q => getQuantile(values, q)),\n        mean: getMean(values),\n    } as BoxPlotSummary\n}\n", "import { useMemo, useState } from 'react'\nimport { SpringConfig, useTransition } from '@react-spring/web'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport { PropertyAccessor, usePropertyAccessor, useTheme, useValueFormatter } from '@nivo/core'\nimport {\n    BoxPlotCommonProps,\n    BoxPlotDatum,\n    BoxPlotItemProps,\n    BoxPlotSummary,\n    ComputedBoxPlotSummary,\n    DataProps,\n    LegendData,\n} from './types'\nimport { defaultProps } from './props'\nimport { generateBoxPlots, getLegendData, stratifyData, summarizeDistribution } from './compute'\nimport { LegendProps } from '@nivo/legends'\n\nexport const useLevels = <RawDatum extends BoxPlotDatum>(\n    levels: string[] | null,\n    data: RawDatum[],\n    by: PropertyAccessor<RawDatum, string> | null\n) => {\n    const getLevel = usePropertyAccessor(by ?? 'id')\n    if (levels) return levels\n    if (!by) return null\n    const result = new Set(data.map((d: RawDatum) => getLevel(d)))\n    return Array.from(result)\n}\n\nexport const useBoxPlot = <RawDatum extends BoxPlotDatum>({\n    data,\n    value,\n    groupBy,\n    groups = defaultProps.groups,\n    subGroupBy = defaultProps.subGroupBy,\n    subGroups = defaultProps.subGroups,\n    quantiles = defaultProps.quantiles,\n    width,\n    height,\n    layout,\n    minValue,\n    maxValue,\n    valueScale = defaultProps.valueScale,\n    indexScale = defaultProps.indexScale,\n    padding = defaultProps.padding,\n    innerPadding = defaultProps.innerPadding,\n    colorBy = defaultProps.colorBy,\n    colors = defaultProps.colors,\n    opacity,\n    activeOpacity,\n    inactiveOpacity,\n    borderColor,\n    medianColor,\n    whiskerColor,\n    legendLabel,\n    tooltipLabel,\n    valueFormat = defaultProps.valueFormat,\n    legends = defaultProps.legends,\n}: {\n    data: DataProps<RawDatum>['data']\n    width: number\n    height: number\n} & Pick<\n    BoxPlotCommonProps<RawDatum>,\n    | 'value'\n    | 'groupBy'\n    | 'groups'\n    | 'subGroupBy'\n    | 'subGroups'\n    | 'quantiles'\n    | 'layout'\n    | 'minValue'\n    | 'maxValue'\n    | 'valueScale'\n    | 'indexScale'\n    | 'padding'\n    | 'innerPadding'\n    | 'colorBy'\n    | 'colors'\n    | 'opacity'\n    | 'activeOpacity'\n    | 'inactiveOpacity'\n    | 'borderColor'\n    | 'medianColor'\n    | 'whiskerColor'\n    | 'legendLabel'\n    | 'tooltipLabel'\n    | 'valueFormat'\n    | 'legends'\n>) => {\n    // ensure that groups and subGroups are defined\n    groups = useLevels(groups, data, groupBy)\n    subGroups = useLevels(subGroups, data, subGroupBy)\n    const getGroup = usePropertyAccessor(groupBy ?? 'group')\n    const getSubGroup = usePropertyAccessor(subGroupBy ?? 'subGroup')\n    const getTooltipLabel = usePropertyAccessor(tooltipLabel)\n    const getValue = usePropertyAccessor(value)\n    const formatValue = useValueFormatter(valueFormat)\n\n    const theme = useTheme()\n    const getColor = useOrdinalColorScale(colors, colorBy)\n    // trigger color fetch for all groups and subgroups\n    if (groups && colorBy === 'group') {\n        groups.map(group => getColor({ group } as BoxPlotSummary))\n    }\n    if (subGroups && colorBy === 'subGroup') {\n        subGroups.map(subGroup => getColor({ subGroup } as BoxPlotSummary))\n    }\n\n    const getBorderColor = useInheritedColor<ComputedBoxPlotSummary>(borderColor, theme)\n    const getMedianColor = useInheritedColor<ComputedBoxPlotSummary>(medianColor, theme)\n    const getWhiskerColor = useInheritedColor<ComputedBoxPlotSummary>(whiskerColor, theme)\n\n    // stratify long array with individual data points into arrays that will\n    // feed boxplot representations\n    const dataStratified = stratifyData({\n        data,\n        groups,\n        getGroup,\n        subGroups,\n        getSubGroup,\n    })\n\n    const nSubGroups = Math.max(1, subGroups ? subGroups.length : 1)\n    const dataSummary = useMemo(\n        () =>\n            dataStratified.map((stratum: RawDatum[], index) =>\n                summarizeDistribution({\n                    data: stratum,\n                    getValue,\n                    groups,\n                    subGroups,\n                    groupIndex: Math.floor(index / nSubGroups),\n                    subGroupIndex: index % nSubGroups,\n                    quantiles,\n                })\n            ),\n        [dataStratified, getValue, groups, subGroups, nSubGroups, quantiles]\n    )\n\n    const {\n        boxPlots: unStyledBoxPlots,\n        xScale,\n        yScale,\n    } = useMemo(\n        () =>\n            generateBoxPlots({\n                layout,\n                data: dataSummary.filter(stratum => stratum.n > 0),\n                groups,\n                subGroups,\n                formatValue,\n                minValue,\n                maxValue,\n                width,\n                height,\n                padding,\n                innerPadding,\n                valueScale,\n                indexScale,\n                getTooltipLabel,\n            }),\n        [\n            layout,\n            dataSummary,\n            groups,\n            subGroups,\n            formatValue,\n            minValue,\n            maxValue,\n            width,\n            height,\n            padding,\n            innerPadding,\n            valueScale,\n            indexScale,\n            getTooltipLabel,\n        ]\n    )\n\n    const [activeItem, setActiveItem] = useState<ComputedBoxPlotSummary | null>(null)\n    const activeKeys = useMemo(() => {\n        if (!activeItem) return []\n        const activeGroup = activeItem.group\n        const activeSubGroup = activeItem.subGroup\n        return unStyledBoxPlots\n            .filter(boxPlot => activeGroup === boxPlot.group || activeSubGroup === boxPlot.subGroup)\n            .map(boxPlot => boxPlot.key)\n    }, [unStyledBoxPlots, activeItem])\n\n    const boxPlots: ComputedBoxPlotSummary[] = useMemo(\n        () =>\n            unStyledBoxPlots.map(boxPlot => {\n                let computedOpacity = activeKeys.includes(boxPlot.key)\n                    ? activeOpacity\n                    : inactiveOpacity\n                if (!activeItem) {\n                    computedOpacity = opacity\n                }\n                return {\n                    ...boxPlot,\n                    color: getColor(boxPlot.data),\n                    opacity: computedOpacity,\n                }\n            }),\n        [\n            unStyledBoxPlots,\n            activeItem,\n            activeKeys,\n            opacity,\n            activeOpacity,\n            inactiveOpacity,\n            getColor,\n        ]\n    )\n\n    const legendsData: [LegendProps, LegendData[]][] = useMemo(\n        () =>\n            legends.map(legend => {\n                const data = getLegendData({\n                    boxPlots,\n                    dataFrom: colorBy,\n                    legendLabel,\n                })\n                return [legend, data]\n            }),\n        [legends, boxPlots, colorBy, legendLabel]\n    )\n\n    return {\n        boxPlots,\n        xScale,\n        yScale,\n        getTooltipLabel,\n        formatValue,\n        getColor,\n        getBorderColor,\n        getMedianColor,\n        getWhiskerColor,\n        legendsData,\n        activeItem,\n        setActiveItem,\n    }\n}\n\nexport const useBoxPlotTransition = ({\n    boxPlots,\n    getBorderColor,\n    getMedianColor,\n    getWhiskerColor,\n    animate,\n    springConfig,\n}: {\n    boxPlots: ComputedBoxPlotSummary[]\n    getBorderColor: (d: ComputedBoxPlotSummary) => string\n    getMedianColor: (d: ComputedBoxPlotSummary) => string\n    getWhiskerColor: (d: ComputedBoxPlotSummary) => string\n    animate: boolean\n    springConfig: SpringConfig\n}) => {\n    const getTransitionProps = (boxPlot: ComputedBoxPlotSummary) => ({\n        borderColor: getBorderColor(boxPlot) as string,\n        medianColor: getMedianColor(boxPlot) as string,\n        whiskerColor: getWhiskerColor(boxPlot) as string,\n        color: boxPlot.color,\n        opacity: boxPlot.opacity,\n        valueInterval: Math.abs(boxPlot.coordinates.values[3] - boxPlot.coordinates.values[1]),\n        valueDistance0: boxPlot.coordinates.values[0] - boxPlot.coordinates.values[2],\n        valueDistance1: boxPlot.coordinates.values[1] - boxPlot.coordinates.values[2],\n        valueDistance3: boxPlot.coordinates.values[3] - boxPlot.coordinates.values[2],\n        valueDistance4: boxPlot.coordinates.values[4] - boxPlot.coordinates.values[2],\n        // translate to the midpoint of the median line\n        transform:\n            boxPlot.layout === 'vertical'\n                ? `translate(${boxPlot.x + boxPlot.width / 2}, ${boxPlot.coordinates.values[2]})`\n                : `translate(${boxPlot.coordinates.values[2]}, ${\n                      boxPlot.y + boxPlot.height / 2\n                  }) rotate(-90)`,\n    })\n\n    return useTransition<ComputedBoxPlotSummary, BoxPlotItemProps<BoxPlotDatum>['animatedProps']>(\n        boxPlots,\n        {\n            keys: boxPlot => boxPlot.key,\n            initial: animate ? undefined : null, // required for ssr\n            from: boxPlot => ({\n                ...getTransitionProps(boxPlot),\n                valueInterval: 0,\n                valueDistance0: 0,\n                valueDistance1: 0,\n                valueDistance3: 0,\n                valueDistance4: 0,\n            }),\n            enter: boxPlot => ({ ...getTransitionProps(boxPlot) }),\n            update: boxPlot => ({ ...getTransitionProps(boxPlot) }),\n            leave: boxPlot => ({\n                ...getTransitionProps(boxPlot),\n                valueInterval: 0,\n                valueDistance0: 0,\n                valueDistance1: 0,\n                valueDistance3: 0,\n                valueDistance4: 0,\n            }),\n            config: springConfig,\n            immediate: !animate,\n        }\n    )\n}\n", "import { BoxPlotDatum, BoxPlotCommonProps, ComputedBoxPlotSummary, LegendData } from '../types'\nimport { getPropertyAccessor } from '@nivo/core'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\n\nexport const getLegendData = <RawDatum extends BoxPlotDatum>({\n    boxPlots,\n    dataFrom,\n    legendLabel,\n}: {\n    boxPlots: ComputedBoxPlotSummary[]\n    dataFrom: BoxPlotCommonProps<RawDatum>['colorBy']\n    legendLabel: BoxPlotCommonProps<RawDatum>['legendLabel']\n}) => {\n    const getLegendLabel = getPropertyAccessor(legendLabel ?? dataFrom)\n    const byGroup = dataFrom === 'group'\n    const legendData = boxPlots.map(\n        boxPlot =>\n            // id & label are redundant below, but needed for ts in @nivo/legends\n            ({\n                id: byGroup ? boxPlot.data.groupIndex : boxPlot.data.subGroupIndex,\n                label: getLegendLabel(boxPlot?.data),\n                color: boxPlot?.color,\n            } as LegendData)\n    )\n    // reduce to unique labels, then sort by id/index\n    // ensures correct ordering of legends even when certain group-subGroup combos are missing\n    return sortBy(\n        uniqBy(legendData, ({ label }) => label),\n        ({ id }) => id\n    )\n}\n", "import { Fragment, ReactNode, createElement, useMemo } from 'react'\nimport { Axes, Grid } from '@nivo/axes'\nimport {\n    CartesianMarkers,\n    Container,\n    SvgWrapper,\n    // @ts-ignore\n    bindDefs,\n    useDimensions,\n    useMotionConfig,\n} from '@nivo/core'\nimport { BoxPlotAnnotations } from './BoxPlotAnnotations'\nimport { BoxPlotLegends } from './BoxPlotLegends'\nimport {\n    BoxPlotCustomLayerProps,\n    BoxPlotDatum,\n    BoxPlotLayer,\n    BoxPlotLayerId,\n    BoxPlotSvgProps,\n} from './types'\nimport { svgDefaultProps } from './props'\nimport { useBoxPlot, useBoxPlotTransition } from './hooks'\n\ntype InnerBoxPlotProps<RawDatum extends BoxPlotDatum> = Omit<\n    BoxPlotSvgProps<RawDatum>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerBoxPlot = <RawDatum extends BoxPlotDatum>({\n    data,\n    value = svgDefaultProps.value,\n    groupBy = svgDefaultProps.groupBy,\n    groups = svgDefaultProps.groups,\n    subGroupBy = svgDefaultProps.subGroupBy,\n    subGroups = svgDefaultProps.subGroups,\n    quantiles = svgDefaultProps.quantiles,\n\n    margin: partialMargin,\n    width,\n    height,\n\n    layout = svgDefaultProps.layout,\n    minValue = svgDefaultProps.minValue,\n    maxValue = svgDefaultProps.maxValue,\n\n    valueScale = svgDefaultProps.valueScale,\n    indexScale = svgDefaultProps.indexScale,\n\n    padding = svgDefaultProps.padding,\n    innerPadding = svgDefaultProps.innerPadding,\n\n    opacity = svgDefaultProps.opacity,\n    activeOpacity = svgDefaultProps.activeOpacity,\n    inactiveOpacity = svgDefaultProps.inactiveOpacity,\n\n    axisTop,\n    axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n    gridXValues,\n    gridYValues,\n\n    layers = svgDefaultProps.layers as BoxPlotLayer<RawDatum>[],\n    boxPlotComponent = svgDefaultProps.boxPlotComponent,\n\n    colorBy = svgDefaultProps.colorBy,\n    colors = svgDefaultProps.colors,\n    defs = svgDefaultProps.defs,\n    fill,\n    borderRadius = svgDefaultProps.borderRadius,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor = svgDefaultProps.borderColor,\n    medianWidth = svgDefaultProps.medianWidth,\n    medianColor = svgDefaultProps.medianColor,\n    whiskerWidth = svgDefaultProps.whiskerWidth,\n    whiskerColor = svgDefaultProps.whiskerColor,\n    whiskerEndSize = svgDefaultProps.whiskerEndSize,\n\n    markers = svgDefaultProps.markers,\n\n    legendLabel,\n    tooltipLabel = svgDefaultProps.tooltipLabel,\n\n    valueFormat,\n\n    isInteractive = svgDefaultProps.isInteractive,\n    tooltip = svgDefaultProps.tooltip,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n\n    annotations = svgDefaultProps.annotations,\n    legends = svgDefaultProps.legends,\n\n    role = svgDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    isFocusable = svgDefaultProps.isFocusable,\n    boxPlotAriaLabel,\n    boxPlotAriaLabelledBy,\n    boxPlotAriaDescribedBy,\n}: InnerBoxPlotProps<RawDatum>) => {\n    const { animate, config: springConfig } = useMotionConfig()\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        boxPlots,\n        xScale,\n        yScale,\n        getTooltipLabel,\n        getBorderColor,\n        getMedianColor,\n        getWhiskerColor,\n        legendsData,\n        activeItem,\n        setActiveItem,\n    } = useBoxPlot<RawDatum>({\n        data,\n        value,\n        groupBy,\n        groups,\n        subGroupBy,\n        subGroups,\n        quantiles,\n        width: innerWidth,\n        height: innerHeight,\n        layout,\n        minValue,\n        maxValue,\n        valueScale,\n        indexScale,\n        padding,\n        innerPadding,\n        colorBy,\n        colors,\n        opacity,\n        activeOpacity,\n        inactiveOpacity,\n        borderColor,\n        medianColor,\n        whiskerColor,\n        legendLabel,\n        tooltipLabel,\n        valueFormat,\n        legends,\n    })\n\n    const transition = useBoxPlotTransition({\n        boxPlots,\n        getBorderColor,\n        getMedianColor,\n        getWhiskerColor,\n        animate,\n        springConfig,\n    })\n\n    const commonProps = useMemo(\n        () => ({\n            borderRadius,\n            borderWidth,\n            medianWidth,\n            whiskerWidth,\n            whiskerEndSize,\n            padding,\n            innerPadding,\n            isInteractive,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            getTooltipLabel,\n            tooltip,\n            isFocusable,\n            ariaLabel: boxPlotAriaLabel,\n            ariaLabelledBy: boxPlotAriaLabelledBy,\n            ariaDescribedBy: boxPlotAriaDescribedBy,\n            activeItem,\n            setActiveItem,\n        }),\n        [\n            borderRadius,\n            borderWidth,\n            medianWidth,\n            whiskerWidth,\n            whiskerEndSize,\n            padding,\n            innerPadding,\n            isInteractive,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            tooltip,\n            getTooltipLabel,\n            isFocusable,\n            boxPlotAriaLabel,\n            boxPlotAriaLabelledBy,\n            boxPlotAriaDescribedBy,\n            activeItem,\n            setActiveItem,\n        ]\n    )\n\n    const boundDefs = bindDefs(defs, boxPlots, fill, {\n        dataKey: 'data',\n        targetKey: 'fill',\n    })\n\n    const layerById: Record<BoxPlotLayerId, ReactNode> = {\n        annotations: null,\n        axes: null,\n        boxPlots: null,\n        grid: null,\n        legends: null,\n        markers: null,\n    }\n\n    if (layers.includes('annotations')) {\n        layerById.annotations = (\n            <BoxPlotAnnotations key=\"annotations\" boxPlots={boxPlots} annotations={annotations} />\n        )\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (layers.includes('boxPlots')) {\n        layerById.boxPlots = (\n            <Fragment key=\"boxPlots\">\n                {transition((animatedProps, boxPlot) =>\n                    createElement(boxPlotComponent, {\n                        ...commonProps,\n                        boxPlot,\n                        layout,\n                        animatedProps,\n                    })\n                )}\n            </Fragment>\n        )\n    }\n\n    if (layers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <BoxPlotLegends\n                key=\"legends\"\n                width={innerWidth}\n                height={innerHeight}\n                legends={legendsData}\n            />\n        )\n    }\n\n    if (layers.includes('markers')) {\n        layerById.markers = (\n            <CartesianMarkers<number | string, number>\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale as (v: number | string) => number}\n                yScale={yScale as (v: number) => number}\n            />\n        )\n    }\n\n    const layerContext: BoxPlotCustomLayerProps<RawDatum> = useMemo(\n        () => ({\n            ...commonProps,\n            layout,\n            margin,\n            width,\n            height,\n            innerWidth,\n            innerHeight,\n            padding,\n            innerPadding,\n            boxPlots,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            tooltip,\n            getTooltipLabel,\n            xScale,\n            yScale,\n        }),\n        [\n            commonProps,\n            layout,\n            margin,\n            width,\n            height,\n            innerWidth,\n            innerHeight,\n            padding,\n            innerPadding,\n            boxPlots,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            tooltip,\n            getTooltipLabel,\n            xScale,\n            yScale,\n        ]\n    )\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n            isFocusable={isFocusable}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const BoxPlot = <RawDatum extends BoxPlotDatum>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: BoxPlotSvgProps<RawDatum>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerBoxPlot<RawDatum> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n", "import { BoxPlot } from './BoxPlot'\nimport { BoxPlotDatum, BoxPlotSvgProps } from './types'\nimport { ResponsiveWrapper } from '@nivo/core'\n\nexport const ResponsiveBoxPlot = <RawDatum extends BoxPlotDatum>(\n    props: Omit<BoxPlotSvgProps<RawDatum>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <BoxPlot<RawDatum> width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n"],
  "mappings": "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M,aAA2B;EACtC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AH9HF,gBAAQ,OAAO;EACb,gBAAgB;EAChB;EACA;;AAGF,IAAM,OAAO,WAAW,YAAY;EAClC;EACA,qBAAqB,CAAA,UAAS,IAAI,cAAc;EAEhD,mBAAmB,CAAC,OAAkC;AAAlC,iBAAE,aAAW,eAAb,IAA4B,kBAA5B,IAA4B,CAA1B,aAAW;AAA2B;;;AAGvD,IAAM,WAAW,KAAK;;;;;;;;;;;;;;;AInB7B,IAAM,KAAc,SAAC,IAAA;AAA+B,SAAM,EACtD,GAAG,GAAQ,IAAI,GAAQ,QAAQ,GAC/B,GAAG,GAAQ,IAAI,GAAQ,SAAS;;AAFpC,IAKM,IAAgB,SAAH,IAAA;AAAA,MAAM,KAAK,GAAL,OAAO,KAAM,GAAN;AAAM,SAA2C,EAC7E,OAAA,IACA,QAAA,IACA,MAAM,KAAK,IAAI,IAAO;;AAR1B,IAWa,IAAqB,SAAH,IAAA;AAA2D,MAArD,KAAQ,GAAR,UAAU,KAAW,GAAX,aACrC,KAAmB,EAAe,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",
  "names": []
}
