import {
  require_uniq
} from "./chunk-B545YG5G.js";
import {
  O
} from "./chunk-5CPLXP24.js";
import {
  require_cloneDeep
} from "./chunk-VACFL5DY.js";
import {
  Xe,
  pr
} from "./chunk-LIF42OKE.js";
import "./chunk-AD5TROZ4.js";
import "./chunk-NIFAYVBJ.js";
import {
  Fr,
  It,
  Ot,
  St,
  Ur,
  Wn,
  g,
  gn,
  k,
  require_jsx_runtime,
  w,
  wt,
  zt
} from "./chunk-CIEVK6OE.js";
import {
  AnimatedObject,
  FluidValue,
  addFluidObserver,
  callFluidObservers,
  colors2,
  createHost,
  createStringInterpolator2,
  each,
  eachProp,
  getFluidValue,
  globals_exports,
  hasFluidValue,
  is,
  removeFluidObserver,
  toArray,
  useSpring,
  useSprings
} from "./chunk-UROOLUEL.js";
import {
  line_default,
  max,
  min,
  monotoneX,
  monotoneY,
  sum
} from "./chunk-JMENM4FH.js";
import "./chunk-B7PIYN4Z.js";
import "./chunk-V2CXUUTH.js";
import {
  require_react_dom
} from "./chunk-2J4CPGJC.js";
import "./chunk-SEBMSOEZ.js";
import {
  require_react
} from "./chunk-3HGGCXHU.js";
import {
  __objRest,
  __toModule
} from "./chunk-AXQKKFRM.js";

// node_modules/@nivo/sankey/dist/nivo-sankey.es.js
var import_react = __toModule(require_react());
var import_uniq = __toModule(require_uniq());

// node_modules/d3-sankey/src/align.js
function targetDepth(d) {
  return d.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n2) {
  return n2 - 1 - node.height;
}
function justify(node, n2) {
  return node.sourceLinks.length ? node.depth : n2 - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/d3-sankey/src/constant.js
function constant(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-sankey/src/sankey.js
function ascendingSourceBreadth(a2, b) {
  return ascendingBreadth(a2.source, b.source) || a2.index - b.index;
}
function ascendingTargetBreadth(a2, b) {
  return ascendingBreadth(a2.target, b.target) || a2.index - b.index;
}
function ascendingBreadth(a2, b) {
  return a2.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id) {
  const node = nodeById.get(id);
  if (!node)
    throw new Error("missing: " + id);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y0 = node.y0;
    let y1 = y0;
    for (const link of node.sourceLinks) {
      link.y0 = y0 + link.width / 2;
      y0 += link.width;
    }
    for (const link of node.targetLinks) {
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    }
  }
}
function Sankey() {
  let x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  let dx = 24;
  let dy = 8, py;
  let id = defaultId;
  let align = justify;
  let sort;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations = 6;
  function sankey() {
    const graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_2) {
    return arguments.length ? (id = typeof _2 === "function" ? _2 : constant(_2), sankey) : id;
  };
  sankey.nodeAlign = function(_2) {
    return arguments.length ? (align = typeof _2 === "function" ? _2 : constant(_2), sankey) : align;
  };
  sankey.nodeSort = function(_2) {
    return arguments.length ? (sort = _2, sankey) : sort;
  };
  sankey.nodeWidth = function(_2) {
    return arguments.length ? (dx = +_2, sankey) : dx;
  };
  sankey.nodePadding = function(_2) {
    return arguments.length ? (dy = py = +_2, sankey) : dy;
  };
  sankey.nodes = function(_2) {
    return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant(_2), sankey) : nodes;
  };
  sankey.links = function(_2) {
    return arguments.length ? (links = typeof _2 === "function" ? _2 : constant(_2), sankey) : links;
  };
  sankey.linkSort = function(_2) {
    return arguments.length ? (linkSort = _2, sankey) : linkSort;
  };
  sankey.size = function(_2) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_2[0], y1 = +_2[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_2) {
    return arguments.length ? (x0 = +_2[0][0], x1 = +_2[1][0], y0 = +_2[0][1], y1 = +_2[1][1], sankey) : [[x0, y0], [x1, y1]];
  };
  sankey.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, sankey) : iterations;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    for (const [i2, node] of nodes2.entries()) {
      node.index = i2;
      node.sourceLinks = [];
      node.targetLinks = [];
    }
    const nodeById = new Map(nodes2.map((d, i2) => [id(d, i2, nodes2), d]));
    for (const [i2, link] of links2.entries()) {
      link.index = i2;
      let { source, target } = link;
      if (typeof source !== "object")
        source = link.source = find(nodeById, source);
      if (typeof target !== "object")
        target = link.target = find(nodeById, target);
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    }
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n2 = nodes2.length;
    let current = new Set(nodes2);
    let next = new Set();
    let x2 = 0;
    while (current.size) {
      for (const node of current) {
        node.depth = x2;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      }
      if (++x2 > n2)
        throw new Error("circular link");
      current = next;
      next = new Set();
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n2 = nodes2.length;
    let current = new Set(nodes2);
    let next = new Set();
    let x2 = 0;
    while (current.size) {
      for (const node of current) {
        node.height = x2;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      }
      if (++x2 > n2)
        throw new Error("circular link");
      current = next;
      next = new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x2 = max(nodes2, (d) => d.depth) + 1;
    const kx2 = (x1 - x0 - dx) / (x2 - 1);
    const columns = new Array(x2);
    for (const node of nodes2) {
      const i2 = Math.max(0, Math.min(x2 - 1, Math.floor(align.call(null, node, x2))));
      node.layer = i2;
      node.x0 = x0 + i2 * kx2;
      node.x1 = node.x0 + dx;
      if (columns[i2])
        columns[i2].push(node);
      else
        columns[i2] = [node];
    }
    if (sort)
      for (const column of columns) {
        column.sort(sort);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky2 = min(columns, (c) => (y1 - y0 - (c.length - 1) * py) / sum(c, value));
    for (const nodes2 of columns) {
      let y2 = y0;
      for (const node of nodes2) {
        node.y0 = y2;
        node.y1 = y2 + node.value * ky2;
        y2 = node.y1 + py;
        for (const link of node.sourceLinks) {
          link.width = link.value * ky2;
        }
      }
      y2 = (y1 - y2 + py) / (nodes2.length + 1);
      for (let i2 = 0; i2 < nodes2.length; ++i2) {
        const node = nodes2[i2];
        node.y0 += y2 * (i2 + 1);
        node.y1 += y2 * (i2 + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (max(columns, (c) => c.length) - 1));
    initializeNodeBreadths(columns);
    for (let i2 = 0; i2 < iterations; ++i2) {
      const alpha = Math.pow(0.99, i2);
      const beta = Math.max(1 - alpha, (i2 + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i2 = 1, n2 = columns.length; i2 < n2; ++i2) {
      const column = columns[i2];
      for (const target of column) {
        let y2 = 0;
        let w3 = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          let v = value2 * (target.layer - source.layer);
          y2 += targetTop(source, target) * v;
          w3 += v;
        }
        if (!(w3 > 0))
          continue;
        let dy2 = (y2 / w3 - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n2 = columns.length, i2 = n2 - 2; i2 >= 0; --i2) {
      const column = columns[i2];
      for (const source of column) {
        let y2 = 0;
        let w3 = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          let v = value2 * (target.layer - source.layer);
          y2 += sourceTop(source, target) * v;
          w3 += v;
        }
        if (!(w3 > 0))
          continue;
        let dy2 = (y2 / w3 - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i2 = nodes2.length >> 1;
    const subject = nodes2[i2];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i2 - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i2 + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y2, i2, alpha) {
    for (; i2 < nodes2.length; ++i2) {
      const node = nodes2[i2];
      const dy2 = (y2 - node.y0) * alpha;
      if (dy2 > 1e-6)
        node.y0 += dy2, node.y1 += dy2;
      y2 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y2, i2, alpha) {
    for (; i2 >= 0; --i2) {
      const node = nodes2[i2];
      const dy2 = (node.y1 - y2) * alpha;
      if (dy2 > 1e-6)
        node.y0 -= dy2, node.y1 -= dy2;
      y2 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y2 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y2 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y2 -= width;
    }
    return y2;
  }
  function sourceTop(source, target) {
    let y2 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y2 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y2 -= width;
    }
    return y2;
  }
  return sankey;
}

// node_modules/d3-sankey/node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r2) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r2 < 0)
      throw new Error("negative radius: " + r2);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r2, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
    var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r2 < 0)
      throw new Error("negative radius: " + r2);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r2)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r2 + "," + r2 + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r2 * Math.cos(a1)) + "," + (this._y1 = y2 + r2 * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w3, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w3 + "v" + +h + "h" + -w3 + "Z";
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/math.js
var epsilon2 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r2) {
    this._curve.point(r2 * Math.sin(a2), r2 * -Math.cos(a2));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-sankey/node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/diamond.js
var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/star.js
var kr = Math.sin(pi2 / 10) / Math.sin(7 * pi2 / 10);
var kx = Math.sin(tau2 / 10) * kr;
var ky = -Math.cos(tau2 / 10) * kr;

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/triangle.js
var sqrt3 = Math.sqrt(3);

// node_modules/d3-sankey/node_modules/d3-shape/src/symbol/wye.js
var s = Math.sqrt(3) / 2;
var k2 = 1 / Math.sqrt(12);
var a = (k2 / 2 + 1) * 3;

// node_modules/d3-sankey/node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y2) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x2) / 6, (that._y0 + 4 * that._y1 + y2) / 6);
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j2 = x2.length - 1;
    if (j2 > 0) {
      var x0 = x2[0], y0 = y2[0], dx = x2[j2] - x0, dy = y2[j2] - y0, i2 = -1, t2;
      while (++i2 <= j2) {
        t2 = i2 / j2;
        this._basis.point(this._beta * x2[i2] + (1 - this._beta) * (x0 + t2 * dx), this._beta * y2[i2] + (1 - this._beta) * (y0 + t2 * dy));
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x2), that._y2 + that._k * (that._y1 - y2), that._x2, that._y2);
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x2, y2) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon2) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
    y1 = (y1 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon2) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t2) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t2) / 2 : t2;
}
function point4(that, t0, t1) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t1 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t1 = slope3(this, x2, y2)), t1);
        break;
      default:
        point4(this, this._t0, t1 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t1;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n2 = x2.length;
    if (n2) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n2 === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n2 === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i2, n2 = x2.length - 1, m, a2 = new Array(n2), b = new Array(n2), r2 = new Array(n2);
  a2[0] = 0, b[0] = 2, r2[0] = x2[0] + 2 * x2[1];
  for (i2 = 1; i2 < n2 - 1; ++i2)
    a2[i2] = 1, b[i2] = 4, r2[i2] = 4 * x2[i2] + 2 * x2[i2 + 1];
  a2[n2 - 1] = 2, b[n2 - 1] = 7, r2[n2 - 1] = 8 * x2[n2 - 1] + x2[n2];
  for (i2 = 1; i2 < n2; ++i2)
    m = a2[i2] / b[i2 - 1], b[i2] -= m, r2[i2] -= m * r2[i2 - 1];
  a2[n2 - 1] = r2[n2 - 1] / b[n2 - 1];
  for (i2 = n2 - 2; i2 >= 0; --i2)
    a2[i2] = (r2[i2] - a2[i2 + 1]) / b[i2];
  b[n2 - 1] = (x2[n2] + a2[n2 - 1]) / 2;
  for (i2 = 0; i2 < n2 - 1; ++i2)
    b[i2] = 2 * x2[i2 + 1] - a2[i2 + 1];
  return [a2, b];
}

// node_modules/d3-sankey/node_modules/d3-shape/src/curve/step.js
function Step(context, t2) {
  this._context = context;
  this._t = t2;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};

// node_modules/@nivo/sankey/dist/nivo-sankey.es.js
var import_jsx_runtime = __toModule(require_jsx_runtime());
var import_cloneDeep = __toModule(require_cloneDeep());

// node_modules/@nivo/sankey/node_modules/@react-spring/web/dist/react-spring_web.legacy-esm.js
var import_react_dom = __toModule(require_react_dom());
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value2) {
  if (value2 == null || typeof value2 === "boolean" || value2 === "")
    return "";
  if (typeof value2 === "number" && value2 !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value2 + "px";
  return ("" + value2).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const _a = props, {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox
  } = _a, attributes = __objRest(_a, [
    "className",
    "style",
    "children",
    "scrollTop",
    "scrollLeft",
    "viewBox"
  ]);
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase())));
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value2 = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value2);
      } else {
        instance.style[name] = value2;
      }
    }
  }
  names.forEach((name, i2) => {
    instance.setAttribute(name, values[i2]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value2, unit) => is.num(value2) && value2 !== 0 ? value2 + unit : value2;
var isValueIdentity = (value2, id) => is.arr(value2) ? value2.every((v) => isValueIdentity(v, id)) : is.num(value2) ? value2 === id : parseFloat(value2) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor(_a) {
    var _b = _a, { x: x2, y: y2, z: z2 } = _b, style = __objRest(_b, ["x", "y", "z"]);
    const inputs = [];
    const transforms = [];
    if (x2 || y2 || z2) {
      inputs.push([x2 || 0, y2 || 0, z2 || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value2, key) => {
      if (key === "transform") {
        inputs.push([value2 || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value2))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value2));
        transforms.push(key === "rotate3d" ? ([x22, y22, z22, deg]) => [
          `rotate3d(${x22},${y22},${z22},${addUnit(deg, unit)})`,
          isValueIdentity(deg, 0)
        ] : (input) => [
          `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
          isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
        ]);
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i2) => {
      const arg1 = getFluidValue(input[0]);
      const [t2, id] = this.transforms[i2](is.arr(arg1) ? arg1 : input.map(getFluidValue));
      transform += " " + t2;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  observerAdded(count) {
    if (count == 1)
      each(this.inputs, (input) => each(input, (value2) => hasFluidValue(value2) && addFluidObserver(value2, this)));
  }
  observerRemoved(count) {
    if (count == 0)
      each(this.inputs, (input) => each(input, (value2) => hasFluidValue(value2) && removeFluidObserver(value2, this)));
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  getComponentProps: (_a) => {
    var _b = _a, { scrollTop, scrollLeft } = _b, props = __objRest(_b, ["scrollTop", "scrollLeft"]);
    return props;
  }
});
var animated = host.animated;

// node_modules/@nivo/sankey/dist/nivo-sankey.es.js
function S() {
  return S = Object.assign ? Object.assign.bind() : function(e2) {
    for (var o2 = 1; o2 < arguments.length; o2++) {
      var n2 = arguments[o2];
      for (var t2 in n2)
        Object.prototype.hasOwnProperty.call(n2, t2) && (e2[t2] = n2[t2]);
    }
    return e2;
  }, S.apply(this, arguments);
}
var z = { container: { display: "flex", alignItems: "center" }, sourceChip: { marginRight: 7 }, targetChip: { marginLeft: 7, marginRight: 7 } };
var E = { center, justify, start: left, end: right };
var G = Object.keys(E);
var j = function(e2) {
  return E[e2];
};
var D = { layout: "horizontal", align: "center", sort: "auto", colors: { scheme: "nivo" }, nodeOpacity: 0.75, nodeHoverOpacity: 1, nodeHoverOthersOpacity: 0.15, nodeThickness: 12, nodeSpacing: 12, nodeInnerPadding: 0, nodeBorderWidth: 1, nodeBorderColor: { from: "color", modifiers: [["darker", 0.5]] }, nodeBorderRadius: 0, linkOpacity: 0.25, linkHoverOpacity: 0.6, linkHoverOthersOpacity: 0.15, linkContract: 0, linkBlendMode: "multiply", enableLinkGradient: false, enableLabels: true, label: "id", labelPosition: "inside", labelPadding: 9, labelOrientation: "horizontal", labelTextColor: { from: "color", modifiers: [["darker", 0.8]] }, isInteractive: true, nodeTooltip: function(e2) {
  var o2 = e2.node;
  return (0, import_jsx_runtime.jsx)(w, { id: o2.label, enableChip: true, color: o2.color });
}, linkTooltip: function(e2) {
  var o2 = e2.link;
  return (0, import_jsx_runtime.jsx)(w, { id: (0, import_jsx_runtime.jsxs)("span", { style: z.container, children: [(0, import_jsx_runtime.jsx)(g, { color: o2.source.color, style: z.sourceChip }), (0, import_jsx_runtime.jsx)("strong", { children: o2.source.label }), " > ", (0, import_jsx_runtime.jsx)("strong", { children: o2.target.label }), (0, import_jsx_runtime.jsx)(g, { color: o2.target.color, style: z.targetChip }), (0, import_jsx_runtime.jsx)("strong", { children: o2.formattedValue })] }) });
}, legends: [], layers: ["links", "nodes", "labels", "legends"], role: "img", animate: true, motionConfig: "gentle" };
var V = function(e2) {
  return e2.id;
};
var A = function(n2) {
  var t2 = n2.data, i2 = n2.valueFormat, r2 = n2.layout, c = n2.width, s2 = n2.height, u = n2.sort, h = n2.align, v = n2.colors, p = n2.nodeThickness, g2 = n2.nodeSpacing, f = n2.nodeInnerPadding, y2 = n2.nodeBorderColor, m = n2.label, k3 = n2.labelTextColor, C = (0, import_react.useState)(null), x2 = C[0], O2 = C[1], L2 = (0, import_react.useState)(null), M2 = L2[0], T2 = L2[1], H = (0, import_react.useMemo)(function() {
    if (u !== "auto")
      return u === "input" ? null : u === "ascending" ? function(e2, o2) {
        return e2.value - o2.value;
      } : u === "descending" ? function(e2, o2) {
        return o2.value - e2.value;
      } : u;
  }, [u]), P = u === "input" ? null : void 0, W = (0, import_react.useMemo)(function() {
    return typeof h == "function" ? h : j(h);
  }, [h]), N = zt(), F = pr(v, "id"), R = Xe(y2, N), S2 = Wn(m), z2 = Xe(k3, N), E2 = Ot(i2), G2 = (0, import_react.useMemo)(function() {
    return function(e2) {
      var o2 = e2.data, n3 = e2.formatValue, t3 = e2.layout, i3 = e2.alignFunction, r3 = e2.sortFunction, l = e2.linkSortMode, a2 = e2.nodeThickness, d = e2.nodeSpacing, c2 = e2.nodeInnerPadding, s3 = e2.width, u2 = e2.height, h2 = e2.getColor, v2 = e2.getLabel, p2 = Sankey().nodeAlign(i3).nodeSort(r3).linkSort(l).nodeWidth(a2).nodePadding(d).size(t3 === "horizontal" ? [s3, u2] : [u2, s3]).nodeId(V), g3 = (0, import_cloneDeep.default)(o2);
      return p2(g3), g3.nodes.forEach(function(e3) {
        if (e3.color = h2(e3), e3.label = v2(e3), e3.formattedValue = n3(e3.value), t3 === "horizontal")
          e3.x = e3.x0 + c2, e3.y = e3.y0, e3.width = Math.max(e3.x1 - e3.x0 - 2 * c2, 0), e3.height = Math.max(e3.y1 - e3.y0, 0);
        else {
          e3.x = e3.y0, e3.y = e3.x0 + c2, e3.width = Math.max(e3.y1 - e3.y0, 0), e3.height = Math.max(e3.x1 - e3.x0 - 2 * c2, 0);
          var o3 = e3.x0, i4 = e3.x1;
          e3.x0 = e3.y0, e3.x1 = e3.y1, e3.y0 = o3, e3.y1 = i4;
        }
      }), g3.links.forEach(function(e3) {
        e3.formattedValue = n3(e3.value), e3.color = e3.source.color, e3.pos0 = e3.y0, e3.pos1 = e3.y1, e3.thickness = e3.width, delete e3.y0, delete e3.y1, delete e3.width;
      }), g3;
    }({ data: t2, formatValue: E2, layout: r2, alignFunction: W, sortFunction: H, linkSortMode: P, nodeThickness: p, nodeSpacing: g2, nodeInnerPadding: f, width: c, height: s2, getColor: F, getLabel: S2 });
  }, [t2, E2, r2, W, H, P, p, g2, f, c, s2, F, S2]), D2 = G2.nodes, A2 = G2.links, Z2 = (0, import_react.useMemo)(function() {
    return D2.map(function(e2) {
      return { id: e2.id, label: e2.label, color: e2.color };
    });
  }, [D2]);
  return { nodes: D2, links: A2, legendData: Z2, getNodeBorderColor: R, currentNode: x2, setCurrentNode: O2, currentLink: M2, setCurrentLink: T2, getLabelTextColor: z2 };
};
var Z = function(e2) {
  var o2 = e2.node, i2 = e2.x, r2 = e2.y, l = e2.width, a2 = e2.height, d = e2.color, s2 = e2.opacity, u = e2.borderWidth, h = e2.borderColor, v = e2.borderRadius, p = e2.setCurrent, g2 = e2.isInteractive, f = e2.onClick, y2 = e2.tooltip, m = Ur(), k3 = m.animate, b = m.config, C = useSpring({ x: i2, y: r2, width: l, height: a2, opacity: s2, color: d, config: b, immediate: !k3 }), x2 = k(), M2 = x2.showTooltipFromEvent, T2 = x2.hideTooltip, w3 = (0, import_react.useCallback)(function(e3) {
    p(o2), M2((0, import_react.createElement)(y2, { node: o2 }), e3, "left");
  }, [p, o2, M2, y2]), B = (0, import_react.useCallback)(function(e3) {
    M2((0, import_react.createElement)(y2, { node: o2 }), e3, "left");
  }, [M2, o2, y2]), I = (0, import_react.useCallback)(function() {
    p(null), T2();
  }, [p, T2]), W = (0, import_react.useCallback)(function(e3) {
    f == null || f(o2, e3);
  }, [f, o2]);
  return (0, import_jsx_runtime.jsx)(animated.rect, { x: C.x, y: C.y, rx: v, ry: v, width: C.width.to(function(e3) {
    return Math.max(e3, 0);
  }), height: C.height.to(function(e3) {
    return Math.max(e3, 0);
  }), fill: C.color, fillOpacity: C.opacity, strokeWidth: u, stroke: h, strokeOpacity: s2, onMouseEnter: g2 ? w3 : void 0, onMouseMove: g2 ? B : void 0, onMouseLeave: g2 ? I : void 0, onClick: g2 ? W : void 0 });
};
var q = function(e2) {
  var o2 = e2.nodes, n2 = e2.nodeOpacity, t2 = e2.nodeHoverOpacity, i2 = e2.nodeHoverOthersOpacity, r2 = e2.borderWidth, l = e2.getBorderColor, a2 = e2.borderRadius, d = e2.setCurrentNode, c = e2.currentNode, s2 = e2.currentLink, u = e2.isCurrentNode, h = e2.isInteractive, v = e2.onClick, p = e2.tooltip, g2 = function(e3) {
    return c || s2 ? u(e3) ? t2 : i2 : n2;
  };
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: o2.map(function(e3) {
    return (0, import_jsx_runtime.jsx)(Z, { node: e3, x: e3.x, y: e3.y, width: e3.width, height: e3.height, color: e3.color, opacity: g2(e3), borderWidth: r2, borderColor: l(e3), borderRadius: a2, setCurrent: d, isInteractive: h, onClick: v, tooltip: p }, e3.id);
  }) });
};
var U = function(e2) {
  var o2 = e2.id, n2 = e2.layout, t2 = e2.startColor, i2 = e2.endColor;
  return (0, import_jsx_runtime.jsxs)("linearGradient", S({ id: o2, spreadMethod: "pad" }, n2 === "horizontal" ? { x1: "0%", x2: "100%", y1: "0%", y2: "0%" } : { x1: "0%", x2: "0%", y1: "0%", y2: "100%" }, { children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0%", stopColor: t2 }), (0, import_jsx_runtime.jsx)("stop", { offset: "100%", stopColor: i2 })] }));
};
var J = function(e2) {
  var o2 = e2.link, i2 = e2.layout, r2 = e2.path, l = e2.color, a2 = e2.opacity, d = e2.blendMode, u = e2.enableGradient, h = e2.setCurrent, v = e2.tooltip, p = e2.isInteractive, g2 = e2.onClick, f = o2.source.id + "." + o2.target.id + "." + o2.index, y2 = Ur(), m = y2.animate, k3 = y2.config, b = Fr(r2), C = useSpring({ color: l, opacity: a2, config: k3, immediate: !m }), x2 = k(), w3 = x2.showTooltipFromEvent, B = x2.hideTooltip, I = (0, import_react.useCallback)(function(e3) {
    h(o2), w3((0, import_react.createElement)(v, { link: o2 }), e3, "left");
  }, [h, o2, w3, v]), W = (0, import_react.useCallback)(function(e3) {
    w3((0, import_react.createElement)(v, { link: o2 }), e3, "left");
  }, [w3, o2, v]), N = (0, import_react.useCallback)(function() {
    h(null), B();
  }, [h, B]), F = (0, import_react.useCallback)(function(e3) {
    g2 == null || g2(o2, e3);
  }, [g2, o2]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [u && (0, import_jsx_runtime.jsx)(U, { id: f, layout: i2, startColor: o2.startColor || o2.source.color, endColor: o2.endColor || o2.target.color }), (0, import_jsx_runtime.jsx)(animated.path, { fill: u ? 'url("#' + encodeURI(f) + '")' : C.color, d: b, fillOpacity: C.opacity, onMouseEnter: p ? I : void 0, onMouseMove: p ? W : void 0, onMouseLeave: p ? N : void 0, onClick: p ? F : void 0, style: { mixBlendMode: d } })] });
};
var K = function(e2) {
  var n2 = e2.links, t2 = e2.layout, i2 = e2.linkOpacity, r2 = e2.linkHoverOpacity, l = e2.linkHoverOthersOpacity, a2 = e2.linkContract, d = e2.linkBlendMode, c = e2.enableLinkGradient, s2 = e2.setCurrentLink, u = e2.currentLink, h = e2.currentNode, v = e2.isCurrentLink, p = e2.isInteractive, g2 = e2.onClick, f = e2.tooltip, y2 = function(e3) {
    return h || u ? v(e3) ? r2 : l : i2;
  }, m = (0, import_react.useMemo)(function() {
    return t2 === "horizontal" ? (e3 = line_default().curve(monotoneX), function(o2, n3) {
      var t3 = Math.max(1, o2.thickness - 2 * n3) / 2, i3 = 0.12 * (o2.target.x0 - o2.source.x1), r3 = [[o2.source.x1, o2.pos0 - t3], [o2.source.x1 + i3, o2.pos0 - t3], [o2.target.x0 - i3, o2.pos1 - t3], [o2.target.x0, o2.pos1 - t3], [o2.target.x0, o2.pos1 + t3], [o2.target.x0 - i3, o2.pos1 + t3], [o2.source.x1 + i3, o2.pos0 + t3], [o2.source.x1, o2.pos0 + t3], [o2.source.x1, o2.pos0 - t3]];
      return e3(r3) + "Z";
    }) : function() {
      var e4 = line_default().curve(monotoneY);
      return function(o2, n3) {
        var t3 = Math.max(1, o2.thickness - 2 * n3) / 2, i3 = 0.12 * (o2.target.y0 - o2.source.y1), r3 = [[o2.pos0 + t3, o2.source.y1], [o2.pos0 + t3, o2.source.y1 + i3], [o2.pos1 + t3, o2.target.y0 - i3], [o2.pos1 + t3, o2.target.y0], [o2.pos1 - t3, o2.target.y0], [o2.pos1 - t3, o2.target.y0 - i3], [o2.pos0 - t3, o2.source.y1 + i3], [o2.pos0 - t3, o2.source.y1], [o2.pos0 + t3, o2.source.y1]];
        return e4(r3) + "Z";
      };
    }();
    var e3;
  }, [t2]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: n2.map(function(e3) {
    return (0, import_jsx_runtime.jsx)(J, { link: e3, layout: t2, path: m(e3, a2), color: e3.color, opacity: y2(e3), blendMode: d, enableGradient: c, setCurrent: s2, isInteractive: p, onClick: g2, tooltip: f }, e3.source.id + "." + e3.target.id + "." + e3.index);
  }) });
};
var Q = function(e2) {
  var o2 = e2.nodes, n2 = e2.layout, t2 = e2.width, i2 = e2.height, r2 = e2.labelPosition, a2 = e2.labelPadding, d = e2.labelOrientation, s2 = e2.getLabelTextColor, u = zt(), h = d === "vertical" ? -90 : 0, v = o2.map(function(e3) {
    var o3, l, c;
    return n2 === "horizontal" ? (l = e3.y + e3.height / 2, e3.x < t2 / 2 ? r2 === "inside" ? (o3 = e3.x1 + a2, c = d === "vertical" ? "middle" : "start") : (o3 = e3.x - a2, c = d === "vertical" ? "middle" : "end") : r2 === "inside" ? (o3 = e3.x - a2, c = d === "vertical" ? "middle" : "end") : (o3 = e3.x1 + a2, c = d === "vertical" ? "middle" : "start")) : n2 === "vertical" && (o3 = e3.x + e3.width / 2, e3.y < i2 / 2 ? r2 === "inside" ? (l = e3.y1 + a2, c = d === "vertical" ? "end" : "middle") : (l = e3.y - a2, c = d === "vertical" ? "start" : "middle") : r2 === "inside" ? (l = e3.y - a2, c = d === "vertical" ? "start" : "middle") : (l = e3.y1 + a2, c = d === "vertical" ? "end" : "middle")), { id: e3.id, label: e3.label, x: o3, y: l, textAnchor: c, color: s2(e3) };
  }), p = Ur(), g2 = p.animate, f = p.config, y2 = useSprings(v.length, v.map(function(e3) {
    return { transform: "translate(" + e3.x + ", " + e3.y + ") rotate(" + h + ")", color: e3.color, config: f, immediate: !g2 };
  }));
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: y2.map(function(e3, o3) {
    var n3 = v[o3];
    return (0, import_jsx_runtime.jsx)(animated.text, { dominantBaseline: "central", textAnchor: n3.textAnchor, transform: e3.transform, style: S({}, u.labels.text, { fill: e3.color, pointerEvents: "none" }), children: n3.label }, n3.id);
  }) });
};
var X = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var Y = function(e2) {
  var o2 = e2.data, n2 = e2.valueFormat, l = e2.layout, a2 = l === void 0 ? D.layout : l, d = e2.sort, c = d === void 0 ? D.sort : d, s2 = e2.align, u = s2 === void 0 ? D.align : s2, p = e2.width, f = e2.height, y2 = e2.margin, m = e2.colors, k3 = m === void 0 ? D.colors : m, b = e2.nodeThickness, C = b === void 0 ? D.nodeThickness : b, x2 = e2.nodeSpacing, O2 = x2 === void 0 ? D.nodeThickness : x2, M2 = e2.nodeInnerPadding, T2 = M2 === void 0 ? D.nodeInnerPadding : M2, w3 = e2.nodeBorderColor, B = w3 === void 0 ? D.nodeBorderColor : w3, I = e2.nodeOpacity, H = I === void 0 ? D.nodeOpacity : I, P = e2.nodeHoverOpacity, W = P === void 0 ? D.nodeHoverOpacity : P, N = e2.nodeHoverOthersOpacity, F = N === void 0 ? D.nodeHoverOthersOpacity : N, R = e2.nodeBorderWidth, z2 = R === void 0 ? D.nodeBorderWidth : R, E2 = e2.nodeBorderRadius, G2 = E2 === void 0 ? D.nodeBorderRadius : E2, j2 = e2.linkOpacity, V2 = j2 === void 0 ? D.linkOpacity : j2, Z2 = e2.linkHoverOpacity, U2 = Z2 === void 0 ? D.linkHoverOpacity : Z2, J2 = e2.linkHoverOthersOpacity, X2 = J2 === void 0 ? D.linkHoverOthersOpacity : J2, Y2 = e2.linkContract, $2 = Y2 === void 0 ? D.linkContract : Y2, _2 = e2.linkBlendMode, ee = _2 === void 0 ? D.linkBlendMode : _2, oe = e2.enableLinkGradient, ne = oe === void 0 ? D.enableLinkGradient : oe, te = e2.enableLabels, ie = te === void 0 ? D.enableLabels : te, re = e2.labelPosition, le = re === void 0 ? D.labelPosition : re, ae = e2.labelPadding, de = ae === void 0 ? D.labelPadding : ae, ce = e2.labelOrientation, se = ce === void 0 ? D.labelOrientation : ce, ue = e2.label, he = ue === void 0 ? D.label : ue, ve = e2.labelTextColor, pe = ve === void 0 ? D.labelTextColor : ve, ge = e2.nodeTooltip, fe = ge === void 0 ? D.nodeTooltip : ge, ye = e2.linkTooltip, me = ye === void 0 ? D.linkTooltip : ye, ke = e2.isInteractive, be = ke === void 0 ? D.isInteractive : ke, Ce = e2.onClick, xe = e2.legends, Oe = xe === void 0 ? D.legends : xe, Le = e2.layers, Me = Le === void 0 ? D.layers : Le, Te = e2.role, we = Te === void 0 ? D.role : Te, Be = e2.ariaLabel, Ie = e2.ariaLabelledBy, He = e2.ariaDescribedBy, Pe = wt(p, f, y2), We = Pe.margin, Ne = Pe.innerWidth, Fe = Pe.innerHeight, Re = Pe.outerWidth, Se = Pe.outerHeight, ze = A({ data: o2, valueFormat: n2, layout: a2, width: Ne, height: Fe, sort: c, align: u, colors: k3, nodeThickness: C, nodeSpacing: O2, nodeInnerPadding: T2, nodeBorderColor: B, label: he, labelTextColor: pe }), Ee = ze.nodes, Ge = ze.links, je = ze.legendData, De = ze.getNodeBorderColor, Ve = ze.currentNode, Ae = ze.setCurrentNode, Ze = ze.currentLink, qe = ze.setCurrentLink, Ue = ze.getLabelTextColor, Je = function() {
    return false;
  }, Ke = function() {
    return false;
  };
  if (Ze && (Je = function(e3) {
    var o3 = e3.id;
    return o3 === Ze.source.id || o3 === Ze.target.id;
  }, Ke = function(e3) {
    var o3 = e3.source, n3 = e3.target;
    return o3.id === Ze.source.id && n3.id === Ze.target.id;
  }), Ve) {
    var Qe = [Ve.id];
    Ge.filter(function(e3) {
      var o3 = e3.source, n3 = e3.target;
      return o3.id === Ve.id || n3.id === Ve.id;
    }).forEach(function(e3) {
      var o3 = e3.source, n3 = e3.target;
      Qe.push(o3.id), Qe.push(n3.id);
    }), Qe = (0, import_uniq.default)(Qe), Je = function(e3) {
      var o3 = e3.id;
      return Qe.includes(o3);
    }, Ke = function(e3) {
      var o3 = e3.source, n3 = e3.target;
      return o3.id === Ve.id || n3.id === Ve.id;
    };
  }
  var Xe2 = { links: Ge, nodes: Ee, margin: We, width: p, height: f, outerWidth: Re, outerHeight: Se }, Ye = { links: null, nodes: null, labels: null, legends: null };
  return Me.includes("links") && (Ye.links = (0, import_jsx_runtime.jsx)(K, { links: Ge, layout: a2, linkContract: $2, linkOpacity: V2, linkHoverOpacity: U2, linkHoverOthersOpacity: X2, linkBlendMode: ee, enableLinkGradient: ne, setCurrentLink: qe, currentNode: Ve, currentLink: Ze, isCurrentLink: Ke, isInteractive: be, onClick: Ce, tooltip: me }, "links")), Me.includes("nodes") && (Ye.nodes = (0, import_jsx_runtime.jsx)(q, { nodes: Ee, nodeOpacity: H, nodeHoverOpacity: W, nodeHoverOthersOpacity: F, borderWidth: z2, borderRadius: G2, getBorderColor: De, setCurrentNode: Ae, currentNode: Ve, currentLink: Ze, isCurrentNode: Je, isInteractive: be, onClick: Ce, tooltip: fe }, "nodes")), Me.includes("labels") && ie && (Ye.labels = (0, import_jsx_runtime.jsx)(Q, { nodes: Ee, layout: a2, width: Ne, height: Fe, labelPosition: le, labelPadding: de, labelOrientation: se, getLabelTextColor: Ue }, "labels")), Me.includes("legends") && (Ye.legends = (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: Oe.map(function(e3, o3) {
    return (0, import_jsx_runtime.jsx)(O, S({}, e3, { containerWidth: Ne, containerHeight: Fe, data: je }), "legend" + o3);
  }) }, "legends")), (0, import_jsx_runtime.jsx)(gn, { width: Re, height: Se, margin: We, role: we, ariaLabel: Be, ariaLabelledBy: Ie, ariaDescribedBy: He, children: Me.map(function(e3, o3) {
    var n3;
    return typeof e3 == "function" ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: (0, import_react.createElement)(e3, Xe2) }, o3) : (n3 = Ye == null ? void 0 : Ye[e3]) != null ? n3 : null;
  }) });
};
var $ = function(e2) {
  var o2 = e2.isInteractive, n2 = o2 === void 0 ? D.isInteractive : o2, t2 = e2.animate, i2 = t2 === void 0 ? D.animate : t2, r2 = e2.motionConfig, l = r2 === void 0 ? D.motionConfig : r2, a2 = e2.theme, d = e2.renderWrapper, c = function(e3, o3) {
    if (e3 == null)
      return {};
    var n3, t3, i3 = {}, r3 = Object.keys(e3);
    for (t3 = 0; t3 < r3.length; t3++)
      n3 = r3[t3], o3.indexOf(n3) >= 0 || (i3[n3] = e3[n3]);
    return i3;
  }(e2, X);
  return (0, import_jsx_runtime.jsx)(St, { animate: i2, isInteractive: n2, motionConfig: l, renderWrapper: d, theme: a2, children: (0, import_jsx_runtime.jsx)(Y, S({ isInteractive: n2 }, c)) });
};
var _ = function(e2) {
  return (0, import_jsx_runtime.jsx)(It, { children: function(o2) {
    var n2 = o2.width, t2 = o2.height;
    return (0, import_jsx_runtime.jsx)($, S({ width: n2, height: t2 }, e2));
  } });
};
export {
  _ as ResponsiveSankey,
  $ as Sankey,
  j as sankeyAlignmentFromProp,
  G as sankeyAlignmentPropKeys,
  E as sankeyAlignmentPropMapping,
  D as svgDefaultProps
};
//# sourceMappingURL=@nivo_sankey.js.map
